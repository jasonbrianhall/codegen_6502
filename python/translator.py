#!/usr/bin/env python3
"""
Python implementation of the translator that generates C++ code
Converted from original translator.hpp/translator.cpp files
"""

import os
import sys
from ast_classes import *
from util import lookup_comment

# Tab character used in translation (4 spaces)
TAB = "    "

# Common constants
AUTOGENERATED_FILE_MESSAGE = "// This is an automatically generated file.\n// Do not edit directly.\n//\n"
LINE_SEPARATOR_COMMENT = "//------------------------------------------------------------------------\n"

class Translator:
    def __init__(self, input_filename, ast_root_node):
        """
        Initialize the translator with the input filename and AST root node
        """
        self.input_filename = input_filename
        self.root = ast_root_node
        self.return_label_index = 0
        self.skip_next_instruction = False
        self.skip_next_instruction_index = 0
        
        # Output strings for different file types
        self.source_output = AUTOGENERATED_FILE_MESSAGE
        self.constant_header_output = AUTOGENERATED_FILE_MESSAGE
        self.data_header_output = AUTOGENERATED_FILE_MESSAGE
        self.data_output = AUTOGENERATED_FILE_MESSAGE
        
        # Perform the translation
        self.translate()

    def get_constant_header_output(self):
        """
        Get the constant header output
        """
        return self.constant_header_output
        
    def get_data_output(self):
        """
        Get the data output
        """
        return self.data_output
        
    def get_data_header_output(self):
        """
        Get the data header output
        """
        return self.data_header_output
        
    def get_source_output(self):
        """
        Get the source output
        """
        return self.source_output
        
    def classify_labels(self):
        """
        Find all data and code labels in the AST
        """
        # Iterate through all root children
        i = 0
        while i < len(self.root.children):
            node = self.root.children[i]
            
            # Skip non-labels
            if node.type != AstType.AST_LABEL:
                i += 1
                continue
                
            label = node
            
            # Handle nested labels
            while True:
                child = label.child
                
                if child.type == AstType.AST_LABEL:
                    # Nested label - classify as alias and continue with child
                    label.label_type = LabelType.LABEL_ALIAS
                    label = label.child
                    
                    # Modify the AST
                    # Pull the nested label out and promote to a child of the root node
                    i += 1
                    self.root.children.insert(i, child)
                    
                    # Go back one so that the iterator points to the child
                    i -= 1
                else:
                    break
                    
            # Check the first child node
            child = label.child
            
            # This should be a list
            assert child.type == AstType.AST_LIST
            
            # Check the type of the first contained list item
            list_node = child
            list_element = list_node.value.node
            assert list_element is not None
            
            if list_element.type == AstType.AST_INSTRUCTION:
                # Code
                label.label_type = LabelType.LABEL_CODE
            elif list_element.type == AstType.AST_DATA8:
                label.label_type = LabelType.LABEL_DATA
            else:
                # Should be impossible
                assert False
                
            i += 1
