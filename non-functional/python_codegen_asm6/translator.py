#!/usr/bin/env python3
"""
Python implementation of the translator that generates C++ code
Converted from original translator.hpp/translator.cpp files
"""

import os
import sys
from ast_classes import *
from util import lookup_comment, map_newline

# Tab character used in translation (4 spaces)
TAB = "    "

# Common constants
AUTOGENERATED_FILE_MESSAGE = "// This is an automatically generated file.\n// Do not edit directly.\n//\n"
LINE_SEPARATOR_COMMENT = "//------------------------------------------------------------------------\n"

class Translator:
    def __init__(self, input_filename, ast_root_node):
        """
        Initialize the translator with the input filename and AST root node
        """
        self.input_filename = input_filename
        self.root = ast_root_node
        self.return_label_index = 0
        self.skip_next_instruction = False
        self.skip_next_instruction_index = 0
        
        # Output strings for different file types
        self.source_output = AUTOGENERATED_FILE_MESSAGE
        self.constant_header_output = AUTOGENERATED_FILE_MESSAGE
        self.data_header_output = AUTOGENERATED_FILE_MESSAGE
        self.data_output = AUTOGENERATED_FILE_MESSAGE
        
        # Perform the translation
        self.do_translation()

    def get_constant_header_output(self):
        """
        Get the constant header output
        """
        return self.constant_header_output
        
    def get_data_output(self):
        """
        Get the data output
        """
        return self.data_output
        
    def get_data_header_output(self):
        """
        Get the data header output
        """
        return self.data_header_output
        
    def get_source_output(self):
        """
        Get the source output
        """
        return self.source_output
        
    def classify_labels(self):
        """
        Find all data and code labels in the AST
        """
        # Iterate through all root children
        i = 0
        while i < len(self.root.children):
            try:
                node = self.root.children[i]
                
                # Skip non-labels
                if node.type != AstType.AST_LABEL:
                    i += 1
                    continue
                    
                label = node
                
                # Handle nested labels
                while True:
                    if not hasattr(label, 'child') or label.child is None:
                        print(f"Warning: Label {label.value.s if hasattr(label, 'value') else 'unknown'} has no child")
                        break
                        
                    child = label.child
                    
                    if child.type == AstType.AST_LABEL:
                        # Nested label - classify as alias and continue with child
                        label.label_type = LabelType.LABEL_ALIAS
                        label = label.child
                        
                        # Modify the AST
                        # Pull the nested label out and promote to a child of the root node
                        i += 1
                        self.root.children.insert(i, child)
                        
                        # Go back one so that the iterator points to the child
                        i -= 1
                    else:
                        break
                        
                # Check the first child node
                if not hasattr(label, 'child') or label.child is None:
                    print(f"Warning: Label {label.value.s if hasattr(label, 'value') else 'unknown'} has no child")
                    i += 1
                    continue
                    
                child = label.child
                
                # This should be a list
                if child.type != AstType.AST_LIST:
                    print(f"Warning: Label {label.value.s} has child of type {child.type} instead of AST_LIST")
                    i += 1
                    continue
                
                # Check the first contained list item
                list_node = child
                if not hasattr(list_node, 'value') or not hasattr(list_node.value, 'node') or list_node.value.node is None:
                    print(f"Warning: List node for label {label.value.s} has no value.node")
                    i += 1
                    continue
                    
                list_element = list_node.value.node
                
                if list_element.type == AstType.AST_INSTRUCTION:
                    # Code
                    label.label_type = LabelType.LABEL_CODE
                elif list_element.type == AstType.AST_DATA8:
                    label.label_type = LabelType.LABEL_DATA
                else:
                    print(f"Warning: Unexpected element type {list_element.type} for label {label.value.s}")
                    # Default to code type
                    label.label_type = LabelType.LABEL_CODE
                    
            except Exception as e:
                print(f"Error processing label at index {i}: {e}")
                # Continue with next label
            
            i += 1
            
    def generate_code(self):
        """
        Generate C++ code for all code labels
        """
        self.source_output += """void SMBEngine::code(int mode)
{
    switch (mode)
    {
    case 0:
        loadConstantData();
        goto Start;
    case 1:
        goto NonMaskableInterrupt;
    }

"""

        # Search through the root node, and grab all code label nodes
        for node in self.root.children:
            if node.type != AstType.AST_LABEL:
                continue
                
            label = node
            if not hasattr(label, 'label_type') or label.label_type != LabelType.LABEL_CODE:
                continue
                
            # Output a C++ label for the label
            self.source_output += f"\n{label.value.s}"
            
            # Output a comment, if the label has one
            if hasattr(label, 'line_number') and label.line_number != 0:
                comment = lookup_comment(label.line_number)
                if comment:
                    # Skip the first character of the ASM comment (;)
                    self.source_output += f" // {comment[1:]}"
                    
            self.source_output += "\n"
            
            try:
                # Translate each piece of code under the label
                list_element = label.child
                while list_element is not None:
                    if not hasattr(list_element, 'value') or not hasattr(list_element.value, 'node'):
                        print(f"Warning: Invalid list element for label {label.value.s}")
                        break
                        
                    instruction = list_element.value.node
                    if instruction.type == AstType.AST_INSTRUCTION:
                        self.source_output += f"{TAB}{self.translate_instruction(instruction)}"
                        
                        if hasattr(instruction, 'line_number') and instruction.line_number != 0:
                            comment = lookup_comment(instruction.line_number)
                            if comment:
                                # Skip the first character of the ASM comment (;)
                                self.source_output += f" // {comment[1:]}"
                                
                        # Add a nice line separator after return statements
                        if instruction.code == RTS:
                            self.source_output += "\n\n"
                            self.source_output += LINE_SEPARATOR_COMMENT
                        else:
                            # Or just a newline for all other instructions
                            self.source_output += "\n"
                        
                        if self.skip_next_instruction:
                            # If we had a .db $2c instruction immediately before this one,
                            # we need to add a label to be able to skip this instruction
                            self.source_output += f"Skip_{self.skip_next_instruction_index}:\n"
                            self.skip_next_instruction = False
                    elif (instruction.type == AstType.AST_DATA8 and 
                          hasattr(instruction, 'value') and 
                          hasattr(instruction.value, 'node') and 
                          hasattr(instruction.value.node, 'value') and 
                          hasattr(instruction.value.node.value, 'node') and 
                          hasattr(instruction.value.node.value.node, 'value') and 
                          hasattr(instruction.value.node.value.node.value, 's') and
                          instruction.value.node.value.node.value.s == "$2c"):
                        # Special case: .db $2c
                        # We need to goto the next instruction
                        self.skip_next_instruction = True
                        self.source_output += f"{TAB}goto Skip_{self.skip_next_instruction_index};\n"
                        self.skip_next_instruction_index += 1
                    
                    list_element = list_element.next
            except Exception as e:
                print(f"Error generating code for label {label.value.s}: {e}")
                
        # Generate a return jump table at the end of the code
        self.source_output += """// Return handler
// This emulates the RTS instruction using a generated jump table
//
Return:
    switch (popReturnIndex())
    {
"""

        for i in range(self.return_label_index):
            self.source_output += f"{TAB}case {i}:\n"
            self.source_output += f"{TAB}{TAB}goto Return_{i};\n"

        self.source_output += f"{TAB}}}\n}}\n"
            
    def generate_constant_declarations(self):
        """
        Generate C++ constant declarations for all decl nodes
        """
        self.constant_header_output += "#ifndef SMBCONSTANTS_HPP\n#define SMBCONSTANTS_HPP\n\n"
        
        # Search through the root node, and grab all Decl nodes
        for node in self.root.children:
            if node.type != AstType.AST_DECL:
                continue
                
            decl = node
            
            try:
                self.constant_header_output += f"#define {decl.value.s} {self.translate_expression(decl.expression)}"
                
                if hasattr(decl, 'line_number') and decl.line_number != 0:
                    comment = lookup_comment(decl.line_number)
                    if comment:
                        # Strip the initial ';' character
                        self.constant_header_output += f" // {comment[1:]}"
            except Exception as e:
                print(f"Error generating constant declaration for {decl.value.s}: {e}")
                
            self.constant_header_output += "\n"
            
        self.constant_header_output += "\n#endif // SMBCONSTANTS_HPP\n"
        
    def generate_data_declarations(self):
        """
        Generate C++ data declarations for all data labels
        """
        # This is for a structure containing all of the addresses
        addresses = """// Data Addresses (16-bit pointers) for Constants
//
struct SMBDataPointers
{
"""
        
        # This is for a list of defines that accesses the pointers inside
        # the SMBData struct
        address_defines = """// Defines for quick access of the addresses within SMBDataPointers
//

"""
        
        # This is for the default constructor of SMBData, which initializes the
        # pointers in the struct
        address_defaults = f"{TAB}SMBDataPointers()\n{TAB}{{\n"
        
        # This is for the actual code that does the loading of the data
        # Also, contains the constant data
        loading = "void SMBEngine::loadConstantData()\n{\n"
        
        # Start storing stuff at 0x8000
        storage_address = 0x8000
        
        for node in self.root.children:
            # Skip non-labels
            if node.type != AstType.AST_LABEL:
                continue
                
            label = node
            
            # Skip labels without a valid type
            if not hasattr(label, 'label_type'):
                continue
                
            # Strip the trailing ':' character
            label_name = label.value.s
            if label_name.endswith(':'):
                label_name = label_name[:-1]
                
            if label.label_type == LabelType.LABEL_DATA or label.label_type == LabelType.LABEL_ALIAS:
                try:
                    if label.label_type == LabelType.LABEL_DATA:
                        # The constant data declaration
                        loading += f"{TAB}// {label_name}\n"
                        loading += f"{TAB}//\n"
                        loading += f"{TAB}const uint8_t {label_name}_data[] = {{"
                        
                        # Translate each data item stored in the label
                        list_element = label.child
                        if list_element is None:
                            print(f"Warning: No child elements for data label {label_name}")
                            continue
                        
                        byte_count = 0
                        while list_element is not None:
                            loading += f"\n{TAB}{TAB}"
                            
                            data_item = list_element.value.node
                            if data_item is None or data_item.type != AstType.AST_DATA8:
                                print(f"Warning: Invalid data item for label {label_name}")
                                break
                            
                            data_list_element = data_item.value.node
                            if data_list_element is None or data_list_element.type != AstType.AST_LIST:
                                print(f"Warning: Invalid data list element for label {label_name}")
                                break
                            
                            while data_list_element is not None:
                                # Translate the data item's expression
                                if hasattr(data_list_element, 'value') and hasattr(data_list_element.value, 'node'):
                                    try:
                                        loading += self.translate_expression(data_list_element.value.node)
                                    except Exception as e:
                                        print(f"Error translating expression: {e}")
                                        loading += "0 /* Error */"
                                else:
                                    loading += "0 /* Invalid node */"
                                
                                if data_list_element.next is not None:
                                    loading += ", "
                                    
                                byte_count += 1
                                
                                data_list_element = data_list_element.next
                                
                            if list_element.next is not None:
                                if hasattr(list_element.next, 'value') and hasattr(list_element.next.value, 'node') and list_element.next.value.node.type != AstType.AST_DATA16:
                                    loading += ","
                                else:
                                    # This only occurs at the very end of the disassembly (the interrupt vectors)
                                    # So we will ignore it
                                    break
                                    
                            # Add comments at the end of the line (if they exist)
                            if hasattr(data_item, 'line_number') and data_item.line_number != 0:
                                comment = lookup_comment(data_item.line_number)
                                if comment:
                                    # Strip the first ';' character
                                    loading += f" // {comment[1:]}"
                                    
                            list_element = list_element.next
                            
                        loading += f"\n{TAB}}};\n"
                        loading += f"{TAB}writeData({label_name}, {label_name}_data, sizeof({label_name}_data));\n\n"
                        
                        # The addresses that point to the data
                        addresses += f"{TAB}uint16_t {label_name}_ptr;\n"
                        
                        address_defines += f"#define {label_name} (dataPointers.{label_name}_ptr)\n"
                        
                        address_defaults += f"{TAB}{TAB}this->{label_name}_ptr = 0x{storage_address:x};\n"
                        
                        storage_address += byte_count
                    # Alias label
                    else:
                        # For aliases, we only need to worry about referencing the aliased value
                        addresses += f"{TAB}uint16_t {label_name}_ptr; // alias\n"
                        
                        address_defines += f"#define {label_name} (dataPointers.{label_name}_ptr)\n"
                        
                        address_defaults += f"{TAB}{TAB}this->{label_name}_ptr = 0x{storage_address:x};\n"
                except Exception as e:
                    print(f"Error generating data declaration for {label_name}: {e}")
                    
        # Also store the first address of free space
        addresses += f"{TAB}uint16_t freeSpaceAddress;\n"
        address_defaults += f"{TAB}{TAB}this->freeSpaceAddress = 0x{storage_address:x};\n"
        
        # Final stuff for the end of each section...
        address_defaults += f"{TAB}}}\n"
        addresses += f"\n{address_defaults}}};\n\n"
        address_defines += "\n"
        loading += "}\n\n"
        
        # Put everything in the correct file
        self.data_header_output += "#ifndef SMBDATAPOINTERS_HPP\n#define SMBDATAPOINTERS_HPP\n\n"
        self.data_header_output += addresses
        self.data_header_output += address_defines
        self.data_header_output += "#endif // SMBDATAPOINTERS_HPP\n"
        
        self.data_output += "#include \"SMB.hpp\"\n\n"
        self.data_output += loading
        
    def index_empty_lines(self):
        """
        Find all empty lines in the file
        """
        try:
            with open(self.input_filename, "r") as f:
                for line_number, line in enumerate(f, 1):
                    if not line.strip():
                        map_newline(line_number)
        except Exception as e:
            print(f"Error reading file: {e}")
            
    def do_translation(self):
        """
        Perform the full translation process
        """
        try:
            # Find all empty lines in the file
            self.index_empty_lines()
            
            # Find all data and code labels
            self.classify_labels()
            
            # Begin generating output
            
            # Put required header
            self.source_output += "#include \"SMB.hpp\"\n\n"
            
            # Generate constant declarations first
            self.generate_constant_declarations()
            
            # Generate data declarations next
            self.generate_data_declarations()
            
            # Finally, generate code
            self.generate_code()
        except Exception as e:
            print(f"Error during translation: {e}")
        
    def translate_branch(self, condition, destination):
        """
        Translate a branch instruction to C++
        """
        return f"if ({condition})\n{TAB}{TAB}goto {destination};"
        
    def translate_expression(self, expr):
        """
        Translate an expression to C++ code
        """
        result = ""
        
        if expr is not None:
            if expr.type == AstType.AST_NAME:
                result = expr.value.s
            elif expr.type == AstType.AST_CONST:
                if expr.value.s[0] == '$':
                    result = "0x" + expr.value.s[1:]
                elif expr.value.s[0] == '%':
                    result = "BOOST_BINARY(" + expr.value.s[1:] + ")"
                else:
                    result = expr.value.s
            elif expr.type == AstType.AST_IMMEDIATE:
                # Take the internal value literally
                result = self.translate_expression(expr.child)
            elif expr.type == AstType.AST_ADD:
                result = self.translate_expression(expr.lhs) + " + " + self.translate_expression(expr.rhs)
            elif expr.type == AstType.AST_SUBTRACT:
                result = self.translate_expression(expr.lhs) + " - " + self.translate_expression(expr.rhs)
            elif expr.type == AstType.AST_HIBYTE:
                result = "HIBYTE(" + self.translate_expression(expr.child) + ")"
            elif expr.type == AstType.AST_LOBYTE:
                result = "LOBYTE(" + self.translate_expression(expr.child) + ")"
            elif expr.type == AstType.AST_INDIRECT:
                result = "M(" + self.translate_expression(expr.child) + ")"
            elif expr.type == AstType.AST_INDEXED_X:
                result = self.translate_expression(expr.child) + " + x"
            elif expr.type == AstType.AST_INDEXED_Y:
                # Check for the special case. If the child expression is indirect,
                # then we must use a 16-bit indirect lookup instead of 8-bit
                child = expr.child
                if child.type == AstType.AST_INDIRECT:
                    result = "W(" + self.translate_expression(child.child) + ") + y"
                else:
                    result = self.translate_expression(child) + " + y"
            else:
                print(f"Warning: Unexpected expression type: {expr.type}")
                result = "0 /* Unknown expression type */"
                
        return result
        
    def translate_instruction(self, inst):
        """
        Translate an instruction to C++ code
        """
        result = ""
        
        try:
            if inst.code == LDA:
                result += "a = " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == LDX:
                result += "x = " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == LDY:
                result += "y = " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == STA:
                result += "writeData(" + self.translate_expression(inst.value.node) + ", a);"
            elif inst.code == STX:
                result += "writeData(" + self.translate_expression(inst.value.node) + ", x);"
            elif inst.code == STY:
                result += "writeData(" + self.translate_expression(inst.value.node) + ", y);"
            elif inst.code == TAX:
                result = "x = a;"
            elif inst.code == TAY:
                result = "y = a;"
            elif inst.code == TXA:
                result = "a = x;"
            elif inst.code == TYA:
                result = "a = y;"
            elif inst.code == TSX:
                result = "x = s;"
            elif inst.code == TXS:
                result = "s = x;"
            elif inst.code == PHA:
                result = "pha();"
            elif inst.code == PHP:
                result = "php();"
            elif inst.code == PLA:
                result = "pla();"
            elif inst.code == PLP:
                result = "plp();"
            elif inst.code == AND:
                result += "a &= " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == EOR:
                result += "a ^= " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == ORA:
                result += "a |= " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == BIT:
                result += "bit(" + self.translate_operand(inst.value.node) + ");"
            elif inst.code == ADC:
                result += "a += " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == SBC:
                result += "a -= " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == CMP:
                result += "compare(a, " + self.translate_operand(inst.value.node) + ");"
            elif inst.code == CPX:
                result += "compare(x, " + self.translate_operand(inst.value.node) + ");"
            elif inst.code == CPY:
                result += "compare(y, " + self.translate_operand(inst.value.node) + ");"
            elif inst.code == INC:
                result += "++" + self.translate_operand(inst.value.node) + ";"
            elif inst.code == INX:
                result += "++x;"
            elif inst.code == INY:
                result += "++y;"
            elif inst.code == DEC:
                result += "--" + self.translate_operand(inst.value.node) + ";"
            elif inst.code == DEX:
                result += "--x;"
            elif inst.code == DEY:
                result += "--y;"
            elif inst.code == ASL:
                if hasattr(inst, 'value') and inst.value.node:
                    result += self.translate_operand(inst.value.node) + " <<= 1;"
                else:
                    result += "a <<= 1;"
            elif inst.code == LSR:
                if hasattr(inst, 'value') and inst.value.node:
                    result += self.translate_operand(inst.value.node) + " >>= 1;"
                else:
                    result += "a >>= 1;"
            elif inst.code == ROL:
                if hasattr(inst, 'value') and inst.value.node:
                    result += self.translate_operand(inst.value.node) + ".rol();"
                else:
                    result += "a.rol();"
            elif inst.code == ROR:
                if hasattr(inst, 'value') and inst.value.node:
                    result += self.translate_operand(inst.value.node) + ".ror();"
                else:
                    result += "a.ror();"
            elif inst.code == JMP:
                # We only care about jumping to labels
                # Jumping to a referenced address is only used once in JumpEngine,
                # which we reimplement in a different way
                if hasattr(inst, 'value') and inst.value.node and inst.value.node.type == AstType.AST_NAME:
                    # Check for special case (jmp EndlessLoop)
                    if inst.value.node.value.s == "EndlessLoop":
                        result += "return;"
                    else:
                        result += "goto " + self.translate_expression(inst.value.node) + ";"
                else:
                    result += "/* jmp instruction with invalid operand */;"
            elif inst.code == JSR:
                # Check for special case (jsr JumpEngine)
                if hasattr(inst, 'value') and inst.value.s == "JumpEngine":
                    # Create a switch-case jump table
                    # using the labels that follow as data
                    result += "switch (a)\n"
                    result += TAB
                    result += "{\n"
                    
                    # Skip our element
                    list_element = inst.parent
                    if list_element is None:
                        result += TAB + "/* Invalid parent for JumpEngine */\n" + TAB + "}"
                        return result
                    
                    list_element = list_element.next
                    index = 0
                    
                    while list_element is not None:
                        result += TAB
                        result += "case "
                        result += str(index)
                        result += ":\n"
                        
                        # A little funky...
                        # We have an outer list element,
                        # which contains a 16-bit data list element (.dw),
                        # which contains another list element,
                        # which contains the name that we want to add to our jump table
                        try:
                            result += TAB
                            result += TAB
                            result += "goto "
                            result += self.translate_expression(list_element.value.node.value.node.value.node)
                            result += ";"
                        except Exception as e:
                            result += TAB
                            result += TAB
                            result += f"/* Error processing jump table entry {index}: {e} */;"
                        
                        # Add comments at the end of the line (if they exist)
                        if hasattr(list_element.value.node, 'line_number') and list_element.value.node.line_number != 0:
                            comment = lookup_comment(list_element.value.node.line_number)
                            if comment:
                                # Strip the first ';' character
                                result += " // "
                                result += (comment[1:])
                                
                        result += "\n"
                        
                        list_element = list_element.next
                        index += 1
                    
                    result += TAB
                    result += "}"
                else:
                    return_label_index_str = str(self.return_label_index)
                    result += f"JSR({inst.value.s}, {return_label_index_str});"
                    self.return_label_index += 1
            elif inst.code == RTS:
                result += "goto Return;"
            elif inst.code == BCC:
                result = self.translate_branch("!c", inst.value.s)
            elif inst.code == BCS:
                result = self.translate_branch("c", inst.value.s)
            elif inst.code == BEQ:
                result = self.translate_branch("z", inst.value.s)
            elif inst.code == BMI:
                result = self.translate_branch("n", inst.value.s)
            elif inst.code == BNE:
                result = self.translate_branch("!z", inst.value.s)
            elif inst.code == BPL:
                result = self.translate_branch("!n", inst.value.s)
            elif inst.code == BVC:
                # For now, just use a placeholder
                result = "/* BVC not implemented */;"
            elif inst.code == BVS:
                # For now, just use a placeholder
                result = "/* BVS not implemented */;"
            elif inst.code == CLC:
                result = "c = 0;"
            elif inst.code == CLD:
                # IGNORE
                result = "/* cld */"
            elif inst.code == CLI:
                # For now, just use a placeholder
                result = "/* CLI not implemented */;"
            elif inst.code == CLV:
                # For now, just use a placeholder
                result = "/* CLV not implemented */;"
            elif inst.code == SEC:
                result = "c = 1;"
            elif inst.code == SED:
                # For now, just use a placeholder
                result = "/* SED not implemented */;"
            elif inst.code == SEI:
                # IGNORE
                result = "/* sei */"
            elif inst.code == BRK:
                # For now, just use a placeholder
                result = "/* BRK not implemented */;"
            elif inst.code == NOP:
                result += "; // nop"
            elif inst.code == RTI:
                result += "return;"
            elif inst.code == SLO:
                result += "// SLO instruction (undocumented) - Shift Left then OR with Accumulator\n"
                result += TAB + "{\n"
                result += TAB + TAB + "uint8_t temp = " + self.translate_operand(inst.value.node) + ";\n"
                result += TAB + TAB + "temp <<= 1; // ASL operation\n"
                result += TAB + TAB + "writeData(" + self.translate_expression(inst.value.node) + ", temp);\n" 
                result += TAB + TAB + "a |= temp; // ORA operation\n"
                result += TAB + "}"
            elif inst.code == DCP:
                result += "// DCP instruction (undocumented) - Decrement Memory then Compare with A\n"
                result += TAB + "{\n"
                result += TAB + TAB + "uint8_t temp = " + self.translate_operand(inst.value.node) + ";\n"
                result += TAB + TAB + "temp--; // DEC operation\n"
                result += TAB + TAB + "writeData(" + self.translate_expression(inst.value.node) + ", temp);\n" 
                result += TAB + TAB + "compare(a, temp); // CMP operation\n"
                result += TAB + "}"      
            elif inst.code == RLA:
                result += "// RLA instruction (undocumented) - Rotate Left then AND with Accumulator\n"
                result += TAB + "{\n"
                result += TAB + TAB + "uint8_t temp = " + self.translate_operand(inst.value.node) + ";\n"
                result += TAB + TAB + "uint8_t old_carry = c;\n"
                result += TAB + TAB + "c = (temp & 0x80) != 0; // Save bit 7 to carry\n"
                result += TAB + TAB + "temp = (temp << 1) | old_carry; // ROL operation\n"
                result += TAB + TAB + "writeData(" + self.translate_expression(inst.value.node) + ", temp);\n" 
                result += TAB + TAB + "a &= temp; // AND operation\n"
                result += TAB + "}"
            elif inst.code == SRE:
                result += "// SRE instruction (undocumented) - Shift Right then EOR with Accumulator\n"
                result += TAB + "{\n"
                result += TAB + TAB + "uint8_t temp = " + self.translate_operand(inst.value.node) + ";\n"
                result += TAB + TAB + "c = (temp & 0x01) != 0; // Save bit 0 to carry\n"
                result += TAB + TAB + "temp >>= 1; // LSR operation\n"
                result += TAB + TAB + "writeData(" + self.translate_expression(inst.value.node) + ", temp);\n" 
                result += TAB + TAB + "a ^= temp; // EOR operation\n"
                result += TAB + "}"
            elif inst.code == LAX:
                result += "// LAX instruction (undocumented) - Load both A and X with the same value\n"
                result += TAB + "{\n"
                result += TAB + TAB + "uint8_t temp = " + self.translate_operand(inst.value.node) + ";\n"
                result += TAB + TAB + "a = temp; // LDA operation\n"
                result += TAB + TAB + "x = temp; // LDX operation\n"
                result += TAB + "}"
            elif inst.code == ISC:
                result += "// ISC instruction (undocumented) - Increment memory, then SBC\n"
                result += TAB + "{\n"
                result += TAB + TAB + "uint8_t temp = " + self.translate_operand(inst.value.node) + ";\n"
                result += TAB + TAB + "temp++; // INC operation\n"
                result += TAB + TAB + "writeData(" + self.translate_expression(inst.value.node) + ", temp);\n" 
                result += TAB + TAB + "a -= temp; // SBC operation\n"
                result += TAB + "}"                                                                    
            else:
                result = f"/* Unknown instruction code: {inst.code} */;"
        except Exception as e:
            result = f"/* Error translating instruction: {e} */;"
            
        return result
        
    def translate_operand(self, operand):
        """
        Translate an operand to C++ code
        """
        result = ""
        
        try:
            if operand is not None:
                # If immediate addressing is not the underlying node, it means read from memory
                if operand.type != AstType.AST_IMMEDIATE:
                    result = "M(" + self.translate_expression(operand) + ")"
                else:
                    result = self.translate_expression(operand)
        except Exception as e:
            result = f"/* Error translating operand: {e} */"
                
        return result
