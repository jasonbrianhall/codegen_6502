"""
Code Translator for 6502 Assembly to C++
"""

import os
from typing import Dict, List, Optional
from ast_nodes import *
from tokens import TokenType
from util import lookup_comment

# Tab character used in translation (4 spaces)
TAB = "    "

AUTOGENERATED_FILE_MESSAGE = "// This is an automatically generated file.\n// Do not edit directly.\n//\n"
LINE_SEPARATOR_COMMENT = "//------------------------------------------------------------------------\n"

class Translator:
    def __init__(self, input_filename: str, ast_root_node: RootNode):
        self.input_filename = input_filename
        self.root = ast_root_node
        self.return_label_index = 0
        self.skip_next_instruction = False
        self.skip_next_instruction_index = 0
        
        # Output streams
        self.source_output = ""
        self.constant_header_output = ""
        self.data_header_output = ""
        self.data_output = ""
        
        # Add headers
        self.source_output += AUTOGENERATED_FILE_MESSAGE
        self.constant_header_output += AUTOGENERATED_FILE_MESSAGE
        self.data_header_output += AUTOGENERATED_FILE_MESSAGE
        self.data_output += AUTOGENERATED_FILE_MESSAGE
        
        self.translate()
    
    def get_constant_header_output(self) -> str:
        return self.constant_header_output
    
    def get_data_output(self) -> str:
        return self.data_output
    
    def get_data_header_output(self) -> str:
        return self.data_header_output
    
    def get_source_output(self) -> str:
        return self.source_output
    
    def classify_labels(self):
        """Classify labels as code, data, or alias"""
        for node in self.root.children:
            if node.type != AstType.AST_LABEL:
                continue
            
            label = node
            
            while True:
                child = label.child
                
                if child.type == AstType.AST_LABEL:
                    # Nested label - classify as alias and promote child
                    label.label_type = LabelType.LABEL_ALIAS
                    
                    # Promote the nested label to root level
                    idx = self.root.children.index(node)
                    self.root.children.insert(idx + 1, child)
                    
                    label = child
                else:
                    break
            
            # Classify based on first child
            child = label.child
            
            if child.type == AstType.AST_LIST:
                list_element = child.value
                if list_element.type == AstType.AST_INSTRUCTION:
                    label.label_type = LabelType.LABEL_CODE
                elif list_element.type == AstType.AST_DATA8:
                    label.label_type = LabelType.LABEL_DATA
                else:
                    raise ValueError("Unknown list element type")
    
    def generate_code(self):
        """Generate the main C++ code"""
        self.source_output += (
            "void SMBEngine::code(int mode)\n"
            "{\n"
            f"{TAB}switch (mode)\n"
            f"{TAB}{{\n"
            f"{TAB}case 0:\n"
            f"{TAB}{TAB}loadConstantData();\n"
            f"{TAB}{TAB}goto Start;\n"
            f"{TAB}case 1:\n"
            f"{TAB}{TAB}goto NonMaskableInterrupt;\n"
            f"{TAB}}}\n\n"
        )
        
        # Generate code for each code label
        for node in self.root.children:
            if node.type != AstType.AST_LABEL:
                continue
            
            label = node
            if label.label_type != LabelType.LABEL_CODE:
                continue
            
            # Output C++ label
            self.source_output += f"\n{label.value}"
            
            # Add comment if available
            if label.line_number != 0:
                comment = lookup_comment(label.line_number)
                if comment:
                    self.source_output += f" // {comment[1:]}"  # Skip ';'
            
            self.source_output += "\n"
            
            # Translate each instruction in the label
            list_element = label.child
            while list_element is not None:
                instruction = list_element.value
                if instruction.type == AstType.AST_INSTRUCTION:
                    self.source_output += f"{TAB}{self.translate_instruction(instruction)}"
                    
                    if instruction.line_number != 0:
                        comment = lookup_comment(instruction.line_number)
                        if comment:
                            self.source_output += f" // {comment[1:]}"  # Skip ';'
                    
                    # Add line separator after return statements
                    if instruction.code == TokenType.RTS.value:
                        self.source_output += f"\n\n{LINE_SEPARATOR_COMMENT}"
                    else:
                        self.source_output += "\n"
                    
                    if self.skip_next_instruction:
                        # Add skip label for .db $2c handling
                        self.source_output += f"Skip_{self.skip_next_instruction_index}:\n"
                        self.skip_next_instruction_index += 1
                        self.skip_next_instruction = False
                
                elif (instruction.type == AstType.AST_DATA8 and 
                      instruction.value.value.value == "$2c"):
                    # Special case: .db $2c generates a goto
                    self.skip_next_instruction = True
                    self.source_output += f"{TAB}goto Skip_{self.skip_next_instruction_index};\n"
                
                list_element = list_element.next
        
        # Generate return jump table
        self.source_output += (
            "// Return handler\n"
            "// This emulates the RTS instruction using a generated jump table\n"
            "//\n"
            "Return:\n"
            f"{TAB}switch (popReturnIndex())\n"
            f"{TAB}{{\n"
        )
        
        for i in range(self.return_label_index):
            self.source_output += (
                f"{TAB}case {i}:\n"
                f"{TAB}{TAB}goto Return_{i};\n"
            )
        
        self.source_output += f"{TAB}}}\n"
        self.source_output += "}\n"
    
    def generate_constant_declarations(self):
        """Generate constant declarations header"""
        self.constant_header_output += (
            "#ifndef SMBCONSTANTS_HPP\n"
            "#define SMBCONSTANTS_HPP\n\n"
        )
        
        for node in self.root.children:
            if node.type != AstType.AST_DECL:
                continue
            
            decl = node
            self.constant_header_output += f"#define {decl.value} {self.translate_expression(decl.expression)}"
            
            if decl.line_number != 0:
                comment = lookup_comment(decl.line_number)
                if comment:
                    self.constant_header_output += f" // {comment[1:]}"  # Strip ';'
            
            self.constant_header_output += "\n"
        
        self.constant_header_output += "\n#endif // SMBCONSTANTS_HPP\n"
    
    def generate_data_declarations(self):
        """Generate data declarations and loading code"""
        # Data structure for addresses
        addresses = (
            "// Data Addresses (16-bit pointers) for Constants\n"
            "//\n"
            "struct SMBDataPointers\n"
            "{\n"
        )
        
        # Address defines
        address_defines = (
            "// Defines for quick access of the addresses within SMBDataPointers\n"
            "//\n\n"
        )
        
        # Constructor defaults
        address_defaults = f"{TAB}SMBDataPointers()\n{TAB}{{\n"
        
        # Data loading code
        loading = "void SMBEngine::loadConstantData()\n{\n"
        
        storage_address = 0x8000
        
        for node in self.root.children:
            if node.type != AstType.AST_LABEL:
                continue
            
            label = node
            label_name = label.value.rstrip(':')  # Remove trailing ':'
            
            if label.label_type in [LabelType.LABEL_DATA, LabelType.LABEL_ALIAS]:
                if label.label_type == LabelType.LABEL_DATA:
                    # Generate constant data
                    loading += (
                        f"{TAB}// {label_name}\n"
                        f"{TAB}//\n"
                        f"{TAB}const uint8_t {label_name}_data[] = {{"
                    )
                    
                    list_element = label.child
                    byte_count = 0
                    
                    while list_element is not None:
                        loading += f"\n{TAB}{TAB}"
                        
                        data_item = list_element.value
                        if data_item.type != AstType.AST_DATA8:
                            break
                        
                        data_list_element = data_item.value
                        while data_list_element is not None:
                            loading += self.translate_expression(data_list_element.value)
                            
                            if data_list_element.next is not None:
                                loading += ", "
                            
                            byte_count += 1
                            data_list_element = data_list_element.next
                        
                        if (list_element.next is not None and 
                            list_element.next.value.type != AstType.AST_DATA16):
                            loading += ","
                        elif list_element.next is not None:
                            break  # End at data16 (interrupt vectors)
                        
                        # Add comments
                        if data_item.line_number != 0:
                            comment = lookup_comment(data_item.line_number)
                            if comment:
                                loading += f" // {comment[1:]}"  # Strip ';'
                        
                        list_element = list_element.next
                    
                    loading += f"\n{TAB}}};\n"
                    loading += f"{TAB}writeData({label_name}, {label_name}_data, sizeof({label_name}_data));\n\n"
                    
                    # Address declarations
                    addresses += f"{TAB}uint16_t {label_name}_ptr;\n"
                    address_defines += f"#define {label_name} (dataPointers.{label_name}_ptr)\n"
                    address_defaults += f"{TAB}{TAB}this->{label_name}_ptr = 0x{storage_address:x};\n"
                    
                    storage_address += byte_count
                
                else:  # LABEL_ALIAS
                    addresses += f"{TAB}uint16_t {label_name}_ptr; // alias\n"
                    address_defines += f"#define {label_name} (dataPointers.{label_name}_ptr)\n"
                    address_defaults += f"{TAB}{TAB}this->{label_name}_ptr = 0x{storage_address:x};\n"
        
        # Free space address
        addresses += f"{TAB}uint16_t freeSpaceAddress;\n"
        address_defaults += f"{TAB}{TAB}this->freeSpaceAddress = 0x{storage_address:x};\n"
        
        # Close constructor
        address_defaults += f"{TAB}}}\n"
        addresses += f"\n{address_defaults}}};\n\n"
        
        address_defines += "\n"
        loading += "}\n\n"
        
        # Write to outputs
        self.data_header_output += (
            "#ifndef SMBDATAPOINTERS_HPP\n"
            "#define SMBDATAPOINTERS_HPP\n\n"
            + addresses + address_defines +
            "#endif // SMBDATAPOINTERS_HPP\n"
        )
        
        self.data_output += "#include \"SMB.hpp\"\n\n" + loading
    
    def index_empty_lines(self):
        """Index empty lines in the input file"""
        try:
            with open(self.input_filename, 'r') as file:
                for line_number, line in enumerate(file, 1):
                    if not line.strip():
                        from util import map_newline
                        map_newline(line_number)
        except FileNotFoundError:
            pass  # File not found, skip indexing
    
    def translate(self):
        """Main translation method"""
        # Index empty lines
        self.index_empty_lines()
        
        # Classify labels
        self.classify_labels()
        
        # Add required headers
        self.source_output += "#include \"SMB.hpp\"\n\n"
        
        # Generate outputs
        self.generate_constant_declarations()
        self.generate_data_declarations()
        self.generate_code()
    
    def translate_branch(self, condition: str, destination: str) -> str:
        """Translate a branch instruction"""
        return (
            f"if ({condition})\n"
            f"{TAB}{TAB}goto {destination};"
        )
    
    def translate_expression(self, expr: AstNode) -> str:
        """Translate an expression to C++"""
        if expr is None:
            return ""
        
        if expr.type == AstType.AST_NAME:
            return expr.value
        elif expr.type == AstType.AST_CONST:
            const_val = expr.value
            if const_val.startswith('$'):
                return f"0x{const_val[1:]}"
            elif const_val.startswith('%'):
                return f"BOOST_BINARY({const_val[1:]})"
            else:
                return const_val
        elif expr.type == AstType.AST_IMMEDIATE:
            return self.translate_expression(expr.child)
        elif expr.type == AstType.AST_ADD:
            return f"{self.translate_expression(expr.lhs)} + {self.translate_expression(expr.rhs)}"
        elif expr.type == AstType.AST_SUBTRACT:
            return f"{self.translate_expression(expr.lhs)} - {self.translate_expression(expr.rhs)}"
        elif expr.type == AstType.AST_HIBYTE:
            return f"HIBYTE({self.translate_expression(expr.child)})"
        elif expr.type == AstType.AST_LOBYTE:
            return f"LOBYTE({self.translate_expression(expr.child)})"
        elif expr.type == AstType.AST_INDIRECT:
            return f"M({self.translate_expression(expr.child)})"
        elif expr.type == AstType.AST_INDEXED_X:
            return f"{self.translate_expression(expr.child)} + x"
        elif expr.type == AstType.AST_INDEXED_Y:
            child = expr.child
            if child.type == AstType.AST_INDIRECT:
                return f"W({self.translate_expression(child.child)}) + y"
            else:
                return f"{self.translate_expression(child)} + y"
        else:
            raise ValueError(f"Unknown expression type: {expr.type}")
    
    def translate_instruction(self, inst: InstructionNode) -> str:
        """Translate a 6502 instruction to C++"""
        code = inst.code
        
        # Load instructions
        if code == TokenType.LDA.value:
            return f"a = {self.translate_operand(inst.value)};"
        elif code == TokenType.LDX.value:
            return f"x = {self.translate_operand(inst.value)};"
        elif code == TokenType.LDY.value:
            return f"y = {self.translate_operand(inst.value)};"
        
        # Store instructions
        elif code == TokenType.STA.value:
            return f"writeData({self.translate_expression(inst.value)}, a);"
        elif code == TokenType.STX.value:
            return f"writeData({self.translate_expression(inst.value)}, x);"
        elif code == TokenType.STY.value:
            return f"writeData({self.translate_expression(inst.value)}, y);"
        
        # Transfer instructions
        elif code == TokenType.TAX.value:
            return "x = a;"
        elif code == TokenType.TAY.value:
            return "y = a;"
        elif code == TokenType.TXA.value:
            return "a = x;"
        elif code == TokenType.TYA.value:
            return "a = y;"
        elif code == TokenType.TSX.value:
            return "x = s;"
        elif code == TokenType.TXS.value:
            return "s = x;"
        
        # Stack instructions
        elif code == TokenType.PHA.value:
            return "pha();"
        elif code == TokenType.PHP.value:
            return "php();"
        elif code == TokenType.PLA.value:
            return "pla();"
        elif code == TokenType.PLP.value:
            return "plp();"
        
        # Logical instructions
        elif code == TokenType.AND.value:
            return f"a &= {self.translate_operand(inst.value)};"
        elif code == TokenType.EOR.value:
            return f"a ^= {self.translate_operand(inst.value)};"
        elif code == TokenType.ORA.value:
            return f"a |= {self.translate_operand(inst.value)};"
        elif code == TokenType.BIT.value:
            return f"bit({self.translate_operand(inst.value)});"
        
        # Arithmetic instructions
        elif code == TokenType.ADC.value:
            return f"a += {self.translate_operand(inst.value)};"
        elif code == TokenType.SBC.value:
            return f"a -= {self.translate_operand(inst.value)};"
        
        # Compare instructions
        elif code == TokenType.CMP.value:
            return f"compare(a, {self.translate_operand(inst.value)});"
        elif code == TokenType.CPX.value:
            return f"compare(x, {self.translate_operand(inst.value)});"
        elif code == TokenType.CPY.value:
            return f"compare(y, {self.translate_operand(inst.value)});"
        
        # Increment/decrement
        elif code == TokenType.INC.value:
            return f"++{self.translate_operand(inst.value)};"
        elif code == TokenType.INX.value:
            return "++x;"
        elif code == TokenType.INY.value:
            return "++y;"
        elif code == TokenType.DEC.value:
            return f"--{self.translate_operand(inst.value)};"
        elif code == TokenType.DEX.value:
            return "--x;"
        elif code == TokenType.DEY.value:
            return "--y;"
        
        # Shift instructions
        elif code == TokenType.ASL.value:
            if inst.value:
                return f"{self.translate_operand(inst.value)} <<= 1;"
            else:
                return "a <<= 1;"
        elif code == TokenType.LSR.value:
            if inst.value:
                return f"{self.translate_operand(inst.value)} >>= 1;"
            else:
                return "a >>= 1;"
        elif code == TokenType.ROL.value:
            if inst.value:
                return f"{self.translate_operand(inst.value)}.rol();"
            else:
                return "a.rol();"
        elif code == TokenType.ROR.value:
            if inst.value:
                return f"{self.translate_operand(inst.value)}.ror();"
            else:
                return "a.ror();"
        
        # Jump instructions
        elif code == TokenType.JMP.value:
            if hasattr(inst.value, 'type') and inst.value.type == AstType.AST_NAME:
                if inst.value.value == "EndlessLoop":
                    return "return;"
                else:
                    return f"goto {self.translate_expression(inst.value)};"
            return "/* jmp (complex) */"
        
        elif code == TokenType.JSR.value:
            if inst.value == "JumpEngine":
                # Generate switch-case jump table
                result = f"switch (a)\n{TAB}{{\n"
                
                # This is a simplified version - in practice, you'd need to 
                # look at the following data elements
                result += f"{TAB}/* Jump table entries would go here */\n"
                result += f"{TAB}}}"
                return result
            else:
                result = f"JSR({inst.value}, {self.return_label_index});"
                self.return_label_index += 1
                return result
        
        elif code == TokenType.RTS.value:
            return "goto Return;"
        
        # Branch instructions
        elif code == TokenType.BCC.value:
            return self.translate_branch("!c", inst.value)
        elif code == TokenType.BCS.value:
            return self.translate_branch("c", inst.value)
        elif code == TokenType.BEQ.value:
            return self.translate_branch("z", inst.value)
        elif code == TokenType.BMI.value:
            return self.translate_branch("n", inst.value)
        elif code == TokenType.BNE.value:
            return self.translate_branch("!z", inst.value)
        elif code == TokenType.BPL.value:
            return self.translate_branch("!n", inst.value)
        elif code == TokenType.BVC.value:
            raise NotImplementedError("BVC instruction not implemented")
        elif code == TokenType.BVS.value:
            raise NotImplementedError("BVS instruction not implemented")
        
        # Flag instructions
        elif code == TokenType.CLC.value:
            return "c = 0;"
        elif code == TokenType.CLD.value:
            return "/* cld */"
        elif code == TokenType.CLI.value:
            raise NotImplementedError("CLI instruction not implemented")
        elif code == TokenType.CLV.value:
            raise NotImplementedError("CLV instruction not implemented")
        elif code == TokenType.SEC.value:
            return "c = 1;"
        elif code == TokenType.SED.value:
            raise NotImplementedError("SED instruction not implemented")
        elif code == TokenType.SEI.value:
            return "/* sei */"
        
        # System instructions
        elif code == TokenType.BRK.value:
            raise NotImplementedError("BRK instruction not implemented")
        elif code == TokenType.NOP.value:
            return "; // nop"
        elif code == TokenType.RTI.value:
            return "return;"
        
        else:
            raise ValueError(f"Unknown instruction code: {code}")
    
    def translate_operand(self, operand: AstNode) -> str:
        """Translate an instruction operand"""
        if operand is None:
            return ""
        
        # If not immediate addressing, read from memory
        if operand.type != AstType.AST_IMMEDIATE:
            return f"M({self.translate_expression(operand)})"
        else:
            return self.translate_expression(operand)
