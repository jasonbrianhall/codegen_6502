#!/usr/bin/env python3
"""
6502 Assembly to C++ Translator
Converts 6502 assembly files to C++ code following the same structure as the original C++ translator.
"""

import re
import json
import sys
import os
from typing import Dict, List, Any, Optional, Tuple
from enum import Enum

class LabelType(Enum):
    NONE = "none"
    ALIAS = "alias" 
    CODE = "code"
    DATA = "data"

class InstructionCode(Enum):
    # Load/Store
    LDA = "lda"
    LDX = "ldx"
    LDY = "ldy"
    STA = "sta"
    STX = "stx"
    STY = "sty"
    
    # Transfer
    TAX = "tax"
    TAY = "tay"
    TXA = "txa"
    TYA = "tya"
    TSX = "tsx"
    TXS = "txs"
    
    # Stack
    PHA = "pha"
    PHP = "php"
    PLA = "pla"
    PLP = "plp"
    
    # Logic
    AND = "and"
    EOR = "eor"
    ORA = "ora"
    BIT = "bit"
    
    # Arithmetic
    ADC = "adc"
    SBC = "sbc"
    CMP = "cmp"
    CPX = "cpx"
    CPY = "cpy"
    
    # Increment/Decrement
    INC = "inc"
    INX = "inx"
    INY = "iny"
    DEC = "dec"
    DEX = "dex"
    DEY = "dey"
    
    # Shift/Rotate
    ASL = "asl"
    LSR = "lsr"
    ROL = "rol"
    ROR = "ror"
    
    # Jump/Branch
    JMP = "jmp"
    JSR = "jsr"
    RTS = "rts"
    BCC = "bcc"
    BCS = "bcs"
    BEQ = "beq"
    BMI = "bmi"
    BNE = "bne"
    BPL = "bpl"
    BVC = "bvc"
    BVS = "bvs"
    
    # Flags
    CLC = "clc"
    CLD = "cld"
    CLI = "cli"
    CLV = "clv"
    SEC = "sec"
    SED = "sed"
    SEI = "sei"
    
    # Other
    BRK = "brk"
    NOP = "nop"
    RTI = "rti"

class AsmToCppTranslator:
    def __init__(self):
        self.current_address = 0x8000
        self.return_label_index = 0
        self.skip_next_instruction = False
        self.skip_next_instruction_index = 0
        self.comment_map = {}
        self.newline_set = set()
        
        # Output streams
        self.source_output = []
        self.constant_header_output = []
        self.data_header_output = []
        self.data_output = []
        
        # Tab character (4 spaces)
        self.TAB = "    "
        self.AUTOGENERATED_MESSAGE = "// This is an automatically generated file.\n// Do not edit directly.\n//\n"
        self.LINE_SEPARATOR = "//------------------------------------------------------------------------\n"
    
    def parse_file(self, filename: str) -> Dict[str, Any]:
        """Parse an ASM file or JSON file and return structured data."""
        
        # Check if it's a JSON file
        if filename.endswith('.json'):
            return self._parse_json_file(filename)
        else:
            return self._parse_asm_file(filename)
    
    def _parse_json_file(self, filename: str) -> Dict[str, Any]:
        """Parse a JSON file (from convert.py output)."""
        print(f"Reading JSON file: {filename}")
        with open(filename, 'r') as f:
            data = json.load(f)
        
        print(f"JSON contains: {len(data.get('labels', []))} labels, {len(data.get('declarations', []))} declarations")
        
        # Debug: show structure of first few items
        if data.get('labels'):
            print("Sample label structure:")
            for i, label in enumerate(data['labels'][:2]):
                print(f"  Label {i}: {label}")
        
        if data.get('declarations'):
            print("Sample declaration structure:")
            for i, decl in enumerate(data['declarations'][:2]):
                print(f"  Declaration {i}: {decl}")
        
        # The convert.py script creates a different structure than we expect
        # Let's normalize it to what our translator expects
        normalized_data = {
            "labels": [],
            "declarations": data.get('declarations', []),
            "directives": data.get('directives', [])
        }
        
        # Process labels from the JSON
        for label_data in data.get('labels', []):
            # Convert the JSON label format to our internal format
            normalized_label = {
                "name": label_data.get('name', ''),
                "type": label_data.get('type', 'unknown'),
                "line": label_data.get('line', 0),
                "content": []
            }
            
            if 'comment' in label_data:
                normalized_label['comment'] = label_data['comment']
            
            # Process the content
            for content_item in label_data.get('content', []):
                if content_item.get('type') == 'instruction':
                    # Normalize instruction format
                    normalized_content = {
                        "type": "instruction",
                        "opcode": content_item.get('opcode', ''),
                        "operand": content_item.get('operand', ''),
                        "line": content_item.get('line', 0)
                    }
                    if 'comment' in content_item:
                        normalized_content['comment'] = content_item['comment']
                    
                    normalized_label['content'].append(normalized_content)
                
                elif content_item.get('type') == 'data':
                    # Normalize data format
                    normalized_content = {
                        "type": "data",
                        "directive": content_item.get('directive', 'byte'),
                        "values": content_item.get('values', []),
                        "line": content_item.get('line', 0)
                    }
                    if 'comment' in content_item:
                        normalized_content['comment'] = content_item['comment']
                    
                    normalized_label['content'].append(normalized_content)
                
                else:
                    # Handle other content types
                    normalized_label['content'].append(content_item)
            
            normalized_data['labels'].append(normalized_label)
        
        print(f"Normalized: {len(normalized_data['labels'])} labels, {len(normalized_data['declarations'])} declarations")
        
        return normalized_data
    
    def _parse_asm_file(self, filename: str) -> Dict[str, Any]:
        """Parse an ASM file and return structured data."""
        result = {
            "labels": [],
            "declarations": [],
            "directives": []
        }
        
        with open(filename, 'r') as f:
            lines = f.readlines()
        
        # Index comments and empty lines
        self._index_comments_and_lines(lines)
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            line_num = i + 1
            
            # Skip empty lines and comments
            if not line or line.startswith(';'):
                i += 1
                continue
            
            # Extract comment if present
            comment = None
            if ';' in line:
                parts = line.split(';', 1)
                line = parts[0].strip()
                comment = parts[1].strip()
            
            # Check for label
            if line.endswith(':'):
                label_data = self._parse_label(line, lines, i, comment)
                if label_data:
                    result["labels"].append(label_data)
                    i += label_data.get("lines_consumed", 1)
                else:
                    i += 1
            
            # Check for declaration (NAME = VALUE)
            elif '=' in line and not line.startswith('.'):
                decl = self._parse_declaration(line, comment, line_num)
                if decl:
                    result["declarations"].append(decl)
                i += 1
            
            # Check for directives
            elif line.startswith('.'):
                directive = self._parse_directive(line, comment, line_num)
                if directive:
                    result["directives"].append(directive)
                i += 1
            
            else:
                # Standalone instruction
                if self._is_instruction(line):
                    inst = self._parse_instruction(line, comment, line_num)
                    if inst:
                        label_data = {
                            "name": f"unlabeled_{line_num:04d}",
                            "type": "code",
                            "address": f"0x{self.current_address:04X}",
                            "line": line_num,
                            "content": [inst]
                        }
                        result["labels"].append(label_data)
                i += 1
        
        return result
    
    def _index_comments_and_lines(self, lines: List[str]):
        """Index comments and empty lines for later lookup."""
        for i, line in enumerate(lines):
            line_num = i + 1
            if not line.strip():
                self.newline_set.add(line_num)
            elif line.strip().startswith(';'):
                self.comment_map[line_num] = line.strip()
    
    def _parse_label(self, label_line: str, all_lines: List[str], start_idx: int, comment: Optional[str]) -> Optional[Dict[str, Any]]:
        """Parse a label and its content."""
        label_name = label_line[:-1]  # Remove ':'
        
        label_data = {
            "name": label_name,
            "type": "unknown",
            "address": f"0x{self.current_address:04X}",
            "line": start_idx + 1,
            "content": [],
            "comment": comment
        }
        
        # Look at following lines
        i = start_idx + 1
        lines_consumed = 1
        
        while i < len(all_lines):
            line = all_lines[i].strip()
            
            if not line:
                i += 1
                lines_consumed += 1
                continue
            
            if line.endswith(':'):
                break
            
            line_comment = None
            if ';' in line:
                parts = line.split(';', 1)
                line = parts[0].strip()
                line_comment = parts[1].strip()
            
            if not line:
                i += 1
                lines_consumed += 1
                continue
            
            # Parse content
            if line.startswith('.db') or line.startswith('.byte'):
                label_data["type"] = "data"
                data_content = self._parse_data_directive(line, line_comment, i + 1)
                if data_content:
                    label_data["content"].append(data_content)
            
            elif line.startswith('.dw') or line.startswith('.word'):
                label_data["type"] = "data"
                data_content = self._parse_data_directive(line, line_comment, i + 1, word_size=True)
                if data_content:
                    label_data["content"].append(data_content)
            
            elif self._is_instruction(line):
                if label_data["type"] == "unknown":
                    label_data["type"] = "code"
                inst = self._parse_instruction(line, line_comment, i + 1)
                if inst:
                    label_data["content"].append(inst)
            
            elif line.startswith('.'):
                directive = self._parse_directive(line, line_comment, i + 1)
                if directive:
                    label_data["content"].append(directive)
            
            i += 1
            lines_consumed += 1
        
        if label_data["type"] == "unknown":
            label_data["type"] = "code" if label_data["content"] else "empty"
        
        label_data["lines_consumed"] = lines_consumed
        return label_data
    
    def _parse_declaration(self, line: str, comment: Optional[str], line_num: int) -> Optional[Dict[str, Any]]:
        """Parse a NAME = VALUE declaration."""
        if '=' not in line:
            return None
        
        parts = line.split('=', 1)
        if len(parts) != 2:
            return None
        
        name = parts[0].strip()
        value = parts[1].strip()
        
        return {
            "name": name,
            "value": value,
            "line": line_num,
            "comment": comment
        }
    
    def _parse_directive(self, line: str, comment: Optional[str], line_num: int) -> Optional[Dict[str, Any]]:
        """Parse a directive."""
        parts = line.split(None, 1)
        directive_name = parts[0]
        directive_args = parts[1] if len(parts) > 1 else ""
        
        return {
            "type": "directive",
            "name": directive_name,
            "args": directive_args,
            "line": line_num,
            "comment": comment
        }
    
    def _parse_data_directive(self, line: str, comment: Optional[str], line_num: int, word_size: bool = False) -> Optional[Dict[str, Any]]:
        """Parse .db or .dw directive."""
        if line.startswith('.db') or line.startswith('.byte'):
            data_part = line[3:].strip()
        elif line.startswith('.dw') or line.startswith('.word'):
            data_part = line[3:].strip()
        else:
            return None
        
        values = []
        if data_part:
            raw_values = data_part.split(',')
            for val in raw_values:
                values.append(val.strip())
        
        return {
            "type": "data",
            "directive": "word" if word_size else "byte",
            "values": values,
            "line": line_num,
            "comment": comment
        }
    
    def _parse_instruction(self, line: str, comment: Optional[str], line_num: int) -> Optional[Dict[str, Any]]:
        """Parse an assembly instruction."""
        parts = line.split(None, 1)
        if not parts:
            return None
        
        opcode = parts[0].lower()
        operand = parts[1] if len(parts) > 1 else ""
        
        return {
            "type": "instruction",
            "opcode": opcode,
            "operand": operand,
            "line": line_num,
            "comment": comment
        }
    
    def _is_instruction(self, line: str) -> bool:
        """Check if a line contains an assembly instruction."""
        if not line or line.startswith('.') or '=' in line:
            return False
        
        instructions = {
            'lda', 'ldx', 'ldy', 'sta', 'stx', 'sty',
            'tax', 'tay', 'txa', 'tya', 'tsx', 'txs',
            'pha', 'php', 'pla', 'plp',
            'and', 'eor', 'ora', 'bit',
            'adc', 'sbc', 'cmp', 'cpx', 'cpy',
            'inc', 'inx', 'iny', 'dec', 'dex', 'dey',
            'asl', 'lsr', 'rol', 'ror',
            'jmp', 'jsr', 'rts', 'rti',
            'bcc', 'bcs', 'beq', 'bmi', 'bne', 'bpl', 'bvc', 'bvs',
            'clc', 'cld', 'cli', 'clv', 'sec', 'sed', 'sei',
            'brk', 'nop'
        }
        
        parts = line.split()
        if parts:
            opcode = parts[0].lower()
            return opcode in instructions
        
        return False
    
    def translate_file(self, input_filename: str, output_dir: str):
        """Main translation function."""
        print(f"Parsing {input_filename}...")
        
        # Parse the assembly file
        parsed_data = self.parse_file(input_filename)
        
        print(f"Found {len(parsed_data['labels'])} labels, {len(parsed_data['declarations'])} declarations")
        
        # Debug: print what we found
        print("\nLabel analysis:")
        for label in parsed_data['labels']:
            content_types = [content.get('type', 'unknown') for content in label['content']]
            instruction_count = content_types.count('instruction')
            data_count = content_types.count('data')
            print(f"  {label['name']}: {instruction_count} instructions, {data_count} data items, {len(label['content'])} total")
        
        # Classify labels
        self._classify_labels(parsed_data["labels"])
        
        # Initialize output streams
        for stream in [self.source_output, self.constant_header_output, 
                      self.data_header_output, self.data_output]:
            stream.clear()
            stream.append(self.AUTOGENERATED_MESSAGE)
        
        # Generate outputs
        self.source_output.append('#include "SMB.hpp"\n\n')
        
        print("Generating constant declarations...")
        self._generate_constant_declarations(parsed_data["declarations"])
        
        print("Generating data declarations...")
        self._generate_data_declarations(parsed_data["labels"])
        
        print("Generating code...")
        self._generate_code(parsed_data["labels"])
        
        # Create output directory
        os.makedirs(output_dir, exist_ok=True)
        
        # Write output files
        self._write_output_files(output_dir)
        
        print(f"Generated files in {output_dir}:")
        print("  SMB.cpp")
        print("  SMBData.cpp") 
        print("  SMBDataPointers.hpp")
        print("  SMBConstants.hpp")
    
    def _classify_labels(self, labels: List[Dict[str, Any]]):
        """Classify labels as code, data, or alias."""
        for label in labels:
            if not label["content"]:
                continue
            
            # Check first content item
            first_item = label["content"][0]
            
            if first_item["type"] == "instruction":
                label["label_type"] = LabelType.CODE.value
            elif first_item["type"] == "data":
                label["label_type"] = LabelType.DATA.value
            else:
                label["label_type"] = LabelType.CODE.value  # Default
    
    def _translate_expression(self, expr: str) -> str:
        """Translate an expression (constants, names, addressing modes)."""
        if not expr:
            return ""
        
        expr = expr.strip()
        print(f"DEBUG: Translating expression: '{expr}'")
        
        # Handle different types of expressions
        
        # Hex constants ($XX) - MOST IMPORTANT FIX
        if expr.startswith('$'):
            hex_part = expr[1:]
            result = f"0x{hex_part}"
            print(f"DEBUG: Hex conversion: '{expr}' -> '{result}'")
            return result
        
        # Binary constants (%XXXXXXXX)
        if expr.startswith('%'):
            return f"BOOST_BINARY({expr[1:]})"
        
        # Decimal constants (numbers)
        if expr.isdigit():
            return expr
        
        # Handle addressing modes and operators
        
        # Indirect addressing (expr)
        if expr.startswith('(') and expr.endswith(')'):
            inner = expr[1:-1]
            return f"M({self._translate_expression(inner)})"
        
        # Indexed X addressing (expr,x)
        if expr.endswith(',x'):
            base_expr = expr[:-2].strip()
            return f"{self._translate_expression(base_expr)} + x"
        
        # Indexed Y addressing (expr,y)
        if expr.endswith(',y'):
            base_expr = expr[:-2].strip()
            # Check for special case: indirect indexed
            if base_expr.startswith('(') and base_expr.endswith(')'):
                inner = base_expr[1:-1]
                return f"W({self._translate_expression(inner)}) + y"
            else:
                return f"{self._translate_expression(base_expr)} + y"
        
        # Low byte operator (<expr)
        if expr.startswith('<'):
            inner = expr[1:]
            return f"LOBYTE({self._translate_expression(inner)})"
        
        # High byte operator (>expr)
        if expr.startswith('>'):
            inner = expr[1:]
            return f"HIBYTE({self._translate_expression(inner)})"
        
        # Addition (expr + expr)
        if '+' in expr:
            parts = expr.split('+', 1)
            if len(parts) == 2:
                left = parts[0].strip()
                right = parts[1].strip()
                return f"{self._translate_expression(left)} + {self._translate_expression(right)}"
        
        # Subtraction (expr - expr)
        if '-' in expr:
            parts = expr.split('-', 1)
            if len(parts) == 2:
                left = parts[0].strip()
                right = parts[1].strip()
                return f"{self._translate_expression(left)} - {self._translate_expression(right)}"
        
        # Default: treat as name/identifier
        print(f"DEBUG: Identifier: '{expr}' -> '{expr}'")
        return expr
    
    def _generate_constant_declarations(self, declarations: List[Dict[str, Any]]):
        """Generate constant declarations header."""
        print(f"Generating {len(declarations)} constant declarations...")
        
        self.constant_header_output.extend([
            "#ifndef SMBCONSTANTS_HPP\n",
            "#define SMBCONSTANTS_HPP\n\n"
        ])
        
        hex_issues = []
        
        for i, decl in enumerate(declarations):
            # Properly translate the value
            original_value = decl['value']
            translated_value = self._translate_expression(original_value)
            
            # Check for potential issues - this is the critical check
            if '$' in translated_value:
                hex_issues.append(f"{decl['name']}: {original_value} -> {translated_value}")
                print(f"ERROR: Failed to translate dollar sign in: {decl['name']} = {original_value} -> {translated_value}")
            
            line = f"#define {decl['name']} {translated_value}"
            
            if decl.get("comment"):
                line += f" // {decl['comment']}"
            
            self.constant_header_output.append(line + "\n")
            
            # Debug first few constants
            if i < 10:
                print(f"  {decl['name']} = {original_value} -> {translated_value}")
        
        if hex_issues:
            print(f"\nERROR: Found {len(hex_issues)} constants with unhandled $ symbols:")
            for issue in hex_issues:
                print(f"  {issue}")
            print("This will cause compilation errors!")
        
        self.constant_header_output.extend([
            "\n#endif // SMBCONSTANTS_HPP\n"
        ])
    
    def _generate_data_declarations(self, labels: List[Dict[str, Any]]):
        """Generate data declarations and pointers."""
        print(f"Generating data declarations for {len(labels)} labels...")
        
        # Data pointers structure
        addresses = [
            "// Data Addresses (16-bit pointers) for Constants\n",
            "//\n",
            "struct SMBDataPointers\n",
            "{\n"
        ]
        
        # Address defines
        address_defines = [
            "// Defines for quick access of the addresses within SMBDataPointers\n",
            "//\n\n"
        ]
        
        # Constructor
        address_defaults = [
            f"{self.TAB}SMBDataPointers()\n",
            f"{self.TAB}{{\n"
        ]
        
        # Loading code
        loading = [
            "void SMBEngine::loadConstantData()\n",
            "{\n"
        ]
        
        storage_address = 0x8000
        data_labels_found = 0
        
        for label in labels:
            # Process data labels regardless of label_type classification
            has_data = any(content["type"] == "data" for content in label["content"])
            if not has_data:
                continue
            
            data_labels_found += 1
            label_name = label["name"].rstrip(':')
            print(f"  Processing data label: {label_name}")
            
            # Generate data array
            loading.extend([
                f"{self.TAB}// {label_name}\n",
                f"{self.TAB}//\n",
                f"{self.TAB}const uint8_t {label_name}_data[] = {{"
            ])
            
            byte_count = 0
            first_data_item = True
            
            for content in label["content"]:
                if content["type"] == "data":
                    if not first_data_item:
                        loading.append(",")
                    loading.append(f"\n{self.TAB}{self.TAB}")
                    
                    for i, value in enumerate(content["values"]):
                        if i > 0:
                            loading.append(", ")
                        loading.append(self._translate_expression(value))
                        byte_count += 1
                    
                    if content.get("comment"):
                        loading.append(f" // {content['comment']}")
                    
                    first_data_item = False
            
            loading.extend([
                f"\n{self.TAB}}};\n",
                f"{self.TAB}writeData({label_name}, {label_name}_data, sizeof({label_name}_data));\n\n"
            ])
            
            # Add pointer declarations
            addresses.append(f"{self.TAB}uint16_t {label_name}_ptr;\n")
            address_defines.append(f"#define {label_name} (dataPointers.{label_name}_ptr)\n")
            address_defaults.append(f"{self.TAB}{self.TAB}this->{label_name}_ptr = 0x{storage_address:04X};\n")
            
            storage_address += byte_count
            print(f"    Generated {byte_count} bytes of data")
        
        print(f"Found {data_labels_found} data labels")
        
        # Finalize structures
        addresses.append(f"{self.TAB}uint16_t freeSpaceAddress;\n")
        address_defaults.extend([
            f"{self.TAB}{self.TAB}this->freeSpaceAddress = 0x{storage_address:04X};\n",
            f"{self.TAB}}}\n"
        ])
        
        addresses.extend(address_defaults)
        addresses.append("};\n\n")
        address_defines.append("\n")
        loading.append("}\n\n")
        
        # Combine for header output
        self.data_header_output.extend([
            "#ifndef SMBDATAPOINTERS_HPP\n",
            "#define SMBDATAPOINTERS_HPP\n\n"
        ])
        self.data_header_output.extend(addresses)
        self.data_header_output.extend(address_defines)
        self.data_header_output.append("#endif // SMBDATAPOINTERS_HPP\n")
        
        # Data output
        self.data_output.extend([
            '#include "SMB.hpp"\n\n'
        ])
        self.data_output.extend(loading)
        
        print(f"Data generation complete. Generated {len(self.data_output)} lines.")
    
    def _generate_code(self, labels: List[Dict[str, Any]]):
        """Generate the main code function."""
        self.source_output.extend([
            "void SMBEngine::code(int mode)\n",
            "{\n",
            f"{self.TAB}switch (mode)\n",
            f"{self.TAB}{{\n",
            f"{self.TAB}case 0:\n",
            f"{self.TAB}{self.TAB}loadConstantData();\n",
            f"{self.TAB}{self.TAB}goto Start;\n",
            f"{self.TAB}case 1:\n",
            f"{self.TAB}{self.TAB}goto NonMaskableInterrupt;\n",
            f"{self.TAB}}}\n\n"
        ])
        
        print(f"Processing {len(labels)} labels for code generation...")
        
        # Generate code for each label
        for label in labels:
            # Process all labels, not just code labels
            if not label["content"]:
                print(f"  Skipping {label['name']} - no content")
                continue
            
            # Check if this label contains any instructions
            has_instructions = any(content["type"] == "instruction" for content in label["content"])
            if not has_instructions:
                print(f"  Skipping {label['name']} - no instructions")
                continue
            
            print(f"  Generating code for {label['name']}")
            
            # Output label - ensure it ends with colon
            label_name = label["name"]
            if not label_name.endswith(':'):
                label_name += ':'
            
            self.source_output.append(f"\n{label_name}")
            
            if label.get("comment"):
                self.source_output.append(f" // {label['comment']}")
            
            self.source_output.append("\n")
            
            # Translate instructions
            instruction_count = 0
            for content in label["content"]:
                if content["type"] == "instruction":
                    translated = self._translate_instruction(content)
                    self.source_output.append(f"{self.TAB}{translated}")
                    instruction_count += 1
                    
                    if content.get("comment"):
                        self.source_output.append(f" // {content['comment']}")
                    
                    # Add line separator after RTS
                    if content["opcode"] == "rts":
                        self.source_output.extend([
                            "\n\n",
                            self.LINE_SEPARATOR
                        ])
                    else:
                        self.source_output.append("\n")
                    
                    # Handle skip instruction logic
                    if self.skip_next_instruction:
                        self.source_output.append(f"Skip_{self.skip_next_instruction_index}:\n")
                        self.skip_next_instruction = False
                        self.skip_next_instruction_index += 1
                
                elif content["type"] == "data":
                    # Handle special .db $2c case
                    if (content["directive"] == "byte" and 
                        len(content["values"]) == 1 and 
                        content["values"][0] == "$2c"):
                        
                        self.skip_next_instruction = True
                        self.source_output.append(f"{self.TAB}goto Skip_{self.skip_next_instruction_index};\n")
            
            print(f"    Generated {instruction_count} instructions")
        
        # Generate return handler
        self.source_output.extend([
            "\n// Return handler\n",
            "// This emulates the RTS instruction using a generated jump table\n",
            "//\n",
            "Return:\n",
            f"{self.TAB}switch (popReturnIndex())\n",
            f"{self.TAB}{{\n"
        ])
        
        for i in range(self.return_label_index):
            self.source_output.extend([
                f"{self.TAB}case {i}:\n",
                f"{self.TAB}{self.TAB}goto Return_{i};\n"
            ])
        
        self.source_output.extend([
            f"{self.TAB}}}\n",
            "}\n"
        ])
        
        print(f"Code generation complete. Generated {len(self.source_output)} lines.")
    
    def _translate_instruction(self, instruction: Dict[str, Any]) -> str:
        """Translate a single instruction to C++."""
        opcode = instruction["opcode"]
        operand = instruction.get("operand", "")
        
        # Load instructions
        if opcode == "lda":
            return f"a = {self._translate_operand(operand)};"
        elif opcode == "ldx":
            return f"x = {self._translate_operand(operand)};"
        elif opcode == "ldy":
            return f"y = {self._translate_operand(operand)};"
        
        # Store instructions
        elif opcode == "sta":
            return f"writeData({self._translate_expression(operand)}, a);"
        elif opcode == "stx":
            return f"writeData({self._translate_expression(operand)}, x);"
        elif opcode == "sty":
            return f"writeData({self._translate_expression(operand)}, y);"
        
        # Transfer instructions
        elif opcode == "tax":
            return "x = a;"
        elif opcode == "tay":
            return "y = a;"
        elif opcode == "txa":
            return "a = x;"
        elif opcode == "tya":
            return "a = y;"
        elif opcode == "tsx":
            return "x = s;"
        elif opcode == "txs":
            return "s = x;"
        
        # Stack instructions
        elif opcode == "pha":
            return "pha();"
        elif opcode == "php":
            return "php();"
        elif opcode == "pla":
            return "pla();"
        elif opcode == "plp":
            return "plp();"
        
        # Logic instructions
        elif opcode == "and":
            return f"a &= {self._translate_operand(operand)};"
        elif opcode == "eor":
            return f"a ^= {self._translate_operand(operand)};"
        elif opcode == "ora":
            return f"a |= {self._translate_operand(operand)};"
        elif opcode == "bit":
            return f"bit({self._translate_operand(operand)});"
        
        # Arithmetic instructions
        elif opcode == "adc":
            return f"a += {self._translate_operand(operand)};"
        elif opcode == "sbc":
            return f"a -= {self._translate_operand(operand)};"
        elif opcode == "cmp":
            return f"compare(a, {self._translate_operand(operand)});"
        elif opcode == "cpx":
            return f"compare(x, {self._translate_operand(operand)});"
        elif opcode == "cpy":
            return f"compare(y, {self._translate_operand(operand)});"
        
        # Increment/Decrement
        elif opcode == "inc":
            return f"++{self._translate_operand(operand)};"
        elif opcode == "inx":
            return "++x;"
        elif opcode == "iny":
            return "++y;"
        elif opcode == "dec":
            return f"--{self._translate_operand(operand)};"
        elif opcode == "dex":
            return "--x;"
        elif opcode == "dey":
            return "--y;"
        
        # Shift/Rotate
        elif opcode == "asl":
            if operand:
                return f"{self._translate_operand(operand)} <<= 1;"
            else:
                return "a <<= 1;"
        elif opcode == "lsr":
            if operand:
                return f"{self._translate_operand(operand)} >>= 1;"
            else:
                return "a >>= 1;"
        elif opcode == "rol":
            if operand:
                return f"{self._translate_operand(operand)}.rol();"
            else:
                return "a.rol();"
        elif opcode == "ror":
            if operand:
                return f"{self._translate_operand(operand)}.ror();"
            else:
                return "a.ror();"
        
        # Jump/Branch
        elif opcode == "jmp":
            if operand == "EndlessLoop":
                return "return;"
            else:
                return f"goto {self._translate_expression(operand)};"
        
        elif opcode == "jsr":
            if operand == "JumpEngine":
                # Special case - generate switch table
                # This would need additional context from following data
                return "/* JSR JumpEngine - needs special handling */"
            else:
                result = f"JSR({operand}, {self.return_label_index});"
                self.return_label_index += 1
                return result
        
        elif opcode == "rts":
            return "goto Return;"
        
        # Conditional branches
        elif opcode == "bcc":
            return self._translate_branch("!c", operand)
        elif opcode == "bcs":
            return self._translate_branch("c", operand)
        elif opcode == "beq":
            return self._translate_branch("z", operand)
        elif opcode == "bmi":
            return self._translate_branch("n", operand)
        elif opcode == "bne":
            return self._translate_branch("!z", operand)
        elif opcode == "bpl":
            return self._translate_branch("!n", operand)
        elif opcode == "bvc":
            return "/* bvc - not implemented */"
        elif opcode == "bvs":
            return "/* bvs - not implemented */"
        
        # Flag instructions
        elif opcode == "clc":
            return "c = 0;"
        elif opcode == "cld":
            return "/* cld */"
        elif opcode == "cli":
            return "/* cli - not implemented */"
        elif opcode == "clv":
            return "/* clv - not implemented */"
        elif opcode == "sec":
            return "c = 1;"
        elif opcode == "sed":
            return "/* sed - not implemented */"
        elif opcode == "sei":
            return "/* sei */"
        
        # Other
        elif opcode == "brk":
            return "/* brk - not implemented */"
        elif opcode == "nop":
            return "; // nop"
        elif opcode == "rti":
            return "return;"
        
        else:
            return f"/* unknown instruction: {opcode} */"
    
    def _translate_branch(self, condition: str, destination: str) -> str:
        """Translate a branch instruction."""
        return f"if ({condition})\n{self.TAB}{self.TAB}goto {destination};"
    
    def _translate_operand(self, operand: str) -> str:
        """Translate an operand (handles memory vs immediate addressing)."""
        if not operand:
            return ""
        
        operand = operand.strip()
        
        # If it's immediate addressing (starts with #), return the expression
        if operand.startswith('#'):
            inner = operand[1:]
            translated = self._translate_expression(inner)
            return translated
        else:
            # Memory addressing
            translated = self._translate_expression(operand)
            return f"M({translated})"
    
    def _write_output_files(self, output_dir: str):
        """Write all output files to the specified directory."""
        
        files_written = []
        
        # SMB.cpp
        source_path = os.path.join(output_dir, "SMB.cpp")
        with open(source_path, 'w') as f:
            content = ''.join(self.source_output)
            f.write(content)
            files_written.append(f"SMB.cpp ({len(content)} chars)")
        
        # SMBData.cpp
        data_path = os.path.join(output_dir, "SMBData.cpp")
        with open(data_path, 'w') as f:
            content = ''.join(self.data_output)
            f.write(content)
            files_written.append(f"SMBData.cpp ({len(content)} chars)")
        
        # SMBDataPointers.hpp
        data_header_path = os.path.join(output_dir, "SMBDataPointers.hpp")
        with open(data_header_path, 'w') as f:
            content = ''.join(self.data_header_output)
            f.write(content)
            files_written.append(f"SMBDataPointers.hpp ({len(content)} chars)")
        
        # SMBConstants.hpp
        const_header_path = os.path.join(output_dir, "SMBConstants.hpp")
        with open(const_header_path, 'w') as f:
            content = ''.join(self.constant_header_output)
            f.write(content)
            files_written.append(f"SMBConstants.hpp ({len(content)} chars)")
        
        print("Files written:")
        for file_info in files_written:
            print(f"  {file_info}")

def main():
    if len(sys.argv) != 3:
        print("Usage: python convert.py <input.asm|input.json> <output_directory>")
        print("  input.asm  - 6502 assembly source file")
        print("  input.json - JSON file from convert.py")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_dir = sys.argv[2]
    
    if not os.path.exists(input_file):
        print(f"Error: Input file '{input_file}' not found")
        sys.exit(1)
    
    translator = AsmToCppTranslator()
    
    try:
        translator.translate_file(input_file, output_dir)
        print(f"Successfully translated {input_file} to C++ in {output_dir}")
        
    except Exception as e:
        print(f"Error during translation: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

def test_translator():
    """Test the translator with a simple example."""
    # Test hex conversion first
    translator = AsmToCppTranslator()
    
    print("Testing hex conversion:")
    test_cases = [
        "$FF", "$2000", "$07fe", "$a5", "$4010", "$0770", 
        "LOBYTE($07fe)", "HIBYTE($07d6)", "$2000 + 1"
    ]
    
    for test in test_cases:
        result = translator._translate_expression(test)
        has_dollar = '$' in result
        print(f"  {test:15} -> {result:20} {'❌ FAILED' if has_dollar else '✅'}")
    
    # Create a simple test ASM file
    test_asm = """
; Test assembly file
STACK_TOP = $FF
ADDRESS_LOW = $0200
ADDRESS_HIGH = $03B3

Start:                  ; Main entry point
    lda #$00           ; Load zero into accumulator
    sta $0200          ; Store to memory location $0200
    lda #$7E           ; Load hex value
    ldx #$10           ; Load X with 16
    jsr Subroutine     ; Call subroutine
    jmp EndlessLoop    ; Jump to endless loop

Subroutine:            ; A simple subroutine
    inx                ; Increment X
    lda $F7            ; Load from hex address
    dex                ; Decrement X
    rts                ; Return

DataTable:             ; Data section
    .db $01, $02, $03, $04
    .db $FF, $5B, $75

EndlessLoop:           ; Infinite loop
    nop
    jmp EndlessLoop
"""
    
    # Write test file
    with open("test.asm", "w") as f:
        f.write(test_asm)
    
    # Translate it
    print("\nTranslating test file...")
    translator.translate_file("test.asm", "test_output")
    
    print("Test translation completed!")
    print("Check the test_output directory for generated files.")
    
    # Clean up
    os.remove("test.asm")

if __name__ == "__main__":
    if len(sys.argv) == 2 and sys.argv[1] == "--test":
        test_translator()
    else:
        main()
