#!/usr/bin/env python3
"""
Python implementation of the translator for asm6 format
Extends the original translator.hpp/translator.cpp files to support asm6 syntax
"""

import os
import sys
from ast_classes_asm6 import *
from util import lookup_comment, map_newline

# Tab character used in translation (4 spaces)
TAB = "    "

# Common constants
AUTOGENERATED_FILE_MESSAGE = "// This is an automatically generated file.\n// Do not edit directly.\n//\n"
LINE_SEPARATOR_COMMENT = "//------------------------------------------------------------------------\n"

class Translator:
    def __init__(self, input_filename, ast_root_node):
        """
        Initialize the translator with the input filename and AST root node
        """
        self.input_filename = input_filename
        self.root = ast_root_node
        self.return_label_index = 0
        self.skip_next_instruction = False
        self.skip_next_instruction_index = 0
        
        # Output strings for different file types
        self.source_output = AUTOGENERATED_FILE_MESSAGE
        self.constant_header_output = AUTOGENERATED_FILE_MESSAGE
        self.data_header_output = AUTOGENERATED_FILE_MESSAGE
        self.data_output = AUTOGENERATED_FILE_MESSAGE
        
        # Perform the translation
        self.do_translation()

    def get_constant_header_output(self):
        """
        Get the constant header output
        """
        return self.constant_header_output
        
    def get_data_output(self):
        """
        Get the data output
        """
        return self.data_output
        
    def get_data_header_output(self):
        """
        Get the data header output
        """
        return self.data_header_output
        
    def get_source_output(self):
        """
        Get the source output
        """
        return self.source_output
        
    def classify_labels(self):
        """
        Find all data and code labels in the AST
        """
        # Iterate through all root children
        i = 0
        while i < len(self.root.children):
            try:
                node = self.root.children[i]
                
                # Skip non-labels
                if node.type != AstType.AST_LABEL:
                    i += 1
                    continue
                    
                label = node
                
                # Handle nested labels
                while True:
                    if not hasattr(label, 'child') or label.child is None:
                        print(f"Warning: Label {label.value.s if hasattr(label, 'value') else 'unknown'} has no child")
                        break
                        
                    child = label.child
                    
                    if child.type == AstType.AST_LABEL:
                        # Nested label - classify as alias and continue with child
                        label.label_type = LabelType.LABEL_ALIAS
                        label = label.child
                        
                        # Modify the AST
                        # Pull the nested label out and promote to a child of the root node
                        i += 1
                        self.root.children.insert(i, child)
                        
                        # Go back one so that the iterator points to the child
                        i -= 1
                    else:
                        break
                        
                # Check the first child node
                if not hasattr(label, 'child') or label.child is None:
                    print(f"Warning: Label {label.value.s if hasattr(label, 'value') else 'unknown'} has no child")
                    i += 1
                    continue
                    
                child = label.child
                
                # This should be a list
                if child.type != AstType.AST_LIST:
                    print(f"Warning: Label {label.value.s} has child of type {child.type} instead of AST_LIST")
                    i += 1
                    continue
                
                # Check the first contained list item
                list_node = child
                if not hasattr(list_node, 'value') or not hasattr(list_node.value, 'node') or list_node.value.node is None:
                    print(f"Warning: List node for label {label.value.s} has no value.node")
                    i += 1
                    continue
                    
                list_element = list_node.value.node
                
                if list_element.type == AstType.AST_INSTRUCTION:
                    # Code
                    label.label_type = LabelType.LABEL_CODE
                elif list_element.type == AstType.AST_DATA8:
                    label.label_type = LabelType.LABEL_DATA
                else:
                    print(f"Warning: Unexpected element type {list_element.type} for label {label.value.s}")
                    # Default to code type
                    label.label_type = LabelType.LABEL_CODE
                    
            except Exception as e:
                print(f"Error processing label at index {i}: {e}")
                # Continue with next label
            
            i += 1
            
    def generate_code(self):
        """
        Generate C++ code for all code labels
        """
        self.source_output += """void SMBEngine::code(int mode)
{
    switch (mode)
    {
    case 0:
        loadConstantData();
        goto Start;
    case 1:
        goto NonMaskableInterrupt;
    }

"""

        # Search through the root node, and grab all code label nodes
        for node in self.root.children:
            if node.type != AstType.AST_LABEL:
                continue
                
            label = node
            if not hasattr(label, 'label_type') or label.label_type != LabelType.LABEL_CODE:
                continue
                
            # Output a C++ label for the label
            # asm6 labels might not end with a colon, so check for that
            label_name = label.value.s
            if label_name.endswith(':'):
                label_name = label_name[:-1]  # Remove the trailing colon
                
            self.source_output += f"\n{label_name}"
            
            # Output a comment, if the label has one
            if hasattr(label, 'line_number') and label.line_number != 0:
                comment = lookup_comment(label.line_number)
                if comment:
                    # Skip the first character of the ASM comment (;)
                    self.source_output += f" // {comment[1:]}"
                    
            self.source_output += ":\n"
            
            try:
                # Translate each piece of code under the label
                list_element = label.child
                while list_element is not None:
                    if not hasattr(list_element, 'value') or not hasattr(list_element.value, 'node'):
                        print(f"Warning: Invalid list element for label {label.value.s}")
                        break
                        
                    instruction = list_element.value.node
                    if instruction.type == AstType.AST_INSTRUCTION:
                        self.source_output += f"{TAB}{self.translate_instruction(instruction)}"
                        
                        if hasattr(instruction, 'line_number') and instruction.line_number != 0:
                            comment = lookup_comment(instruction.line_number)
                            if comment:
                                # Skip the first character of the ASM comment (;)
                                self.source_output += f" // {comment[1:]}"
                                
                        # Add a nice line separator after return statements
                        if instruction.code == RTS:
                            self.source_output += "\n\n"
                            self.source_output += LINE_SEPARATOR_COMMENT
                        else:
                            # Or just a newline for all other instructions
                            self.source_output += "\n"
                        
                        if self.skip_next_instruction:
                            # If we had a .db $2c instruction immediately before this one,
                            # we need to add a label to be able to skip this instruction
                            self.source_output += f"Skip_{self.skip_next_instruction_index}:\n"
                            self.skip_next_instruction = False
                    elif (instruction.type == AstType.AST_DATA8 and 
                          hasattr(instruction, 'value') and 
                          hasattr(instruction.value, 'node') and 
                          hasattr(instruction.value.node, 'value') and 
                          hasattr(instruction.value.node.value, 'node') and 
                          hasattr(instruction.value.node.value.node, 'value') and 
                          hasattr(instruction.value.node.value.node.value, 's') and
                          instruction.value.node.value.node.value.s == "$2C"):
                        # Special case: db $2C or .db $2C
                        # This is a common trick in 6502 assembly to skip the next instruction
                        # We need to goto the next instruction
                        self.skip_next_instruction = True
                        self.source_output += f"{TAB}goto Skip_{self.skip_next_instruction_index};\n"
                        self.skip_next_instruction_index += 1
                    
                    list_element = list_element.next
            except Exception as e:
                print(f"Error generating code for label {label.value.s}: {e}")
                
        # Generate a return jump table at the end of the code
        self.source_output += """// Return handler
// This emulates the RTS instruction using a generated jump table
//
Return:
    switch (popReturnIndex())
    {
"""

        for i in range(self.return_label_index):
            self.source_output += f"{TAB}case {i}:\n"
            self.source_output += f"{TAB}{TAB}goto Return_{i};\n"

        self.source_output += f"{TAB}}}\n}}\n"
            
    def generate_constant_declarations(self):
        """
        Generate C++ constant declarations for all decl nodes
        """
        self.constant_header_output += "#ifndef SMBCONSTANTS_HPP\n#define SMBCONSTANTS_HPP\n\n"
        
        # Search through the root node, and grab all Decl nodes
        for node in self.root.children:
            if node.type != AstType.AST_DECL:
                continue
                
            decl = node
            
            try:
                self.constant_header_output += f"#define {decl.value.s} {self.translate_expression(decl.expression)}"
                
                if hasattr(decl, 'line_number') and decl.line_number != 0:
                    comment = lookup_comment(decl.line_number)
                    if comment:
                        # Strip the initial comment character (either ';' or '/')
                        if comment.startswith(';'):
                            cleaned_comment = comment[1:]
                        elif comment.startswith('//'):
                            cleaned_comment = comment[2:]
                        else:
                            cleaned_comment = comment
                        self.constant_header_output += f" // {cleaned_comment}"
            except Exception as e:
                print(f"Error generating constant declaration for {decl.value.s}: {e}")
                
            self.constant_header_output += "\n"
            
        self.constant_header_output += "\n#endif // SMBCONSTANTS_HPP\n"
        
    def generate_data_declarations(self):
        """
        Generate C++ data declarations for all data labels
        """
        # This is for a structure containing all of the addresses
        addresses = """// Data Addresses (16-bit pointers) for Constants
//
struct SMBDataPointers
{
"""
        
        # This is for a list of defines that accesses the pointers inside
        # the SMBData struct
        address_defines = """// Defines for quick access of the addresses within SMBDataPointers
//

"""
        
        # This is for the default constructor of SMBData, which initializes the
        # pointers in the struct
        address_defaults = f"{TAB}SMBDataPointers()\n{TAB}{{\n"
        
        # This is for the actual code that does the loading of the data
        # Also, contains the constant data
        loading = "void SMBEngine::loadConstantData()\n{\n"
        
        # Start storing stuff at 0x8000
        storage_address = 0x8000
        
        for node in self.root.children:
            # Skip non-labels
            if node.type != AstType.AST_LABEL:
                continue
                
            label = node
            
            # Skip labels without a valid type
            if not hasattr(label, 'label_type'):
                continue
                
            # Strip the trailing ':' character if present
            label_name = label.value.s
            if label_name.endswith(':'):
                label_name = label_name[:-1]
                
            if label.label_type == LabelType.LABEL_DATA or label.label_type == LabelType.LABEL_ALIAS:
                try:
                    if label.label_type == LabelType.LABEL_DATA:
                        # The constant data declaration
                        loading += f"{TAB}// {label_name}\n"
                        loading += f"{TAB}//\n"
                        loading += f"{TAB}const uint8_t {label_name}_data[] = {{"
                        
                        # Translate each data item stored in the label
                        list_element = label.child
                        if list_element is None:
                            print(f"Warning: No child elements for data label {label_name}")
                            continue
                        
                        byte_count = 0
                        while list_element is not None:
                            loading += f"\n{TAB}{TAB}"
                            
                            data_item = list_element.value.node
                            if data_item is None or data_item.type != AstType.AST_DATA8:
                                print(f"Warning: Invalid data item for label {label_name}")
                                break
                            
                            data_list_element = data_item.value.node
                            if data_list_element is None or data_list_element.type != AstType.AST_LIST:
                                print(f"Warning: Invalid data list element for label {label_name}")
                                break
                            
                            while data_list_element is not None:
                                # Translate the data item's expression
                                if hasattr(data_list_element, 'value') and hasattr(data_list_element.value, 'node'):
                                    try:
                                        loading += self.translate_expression(data_list_element.value.node)
                                    except Exception as e:
                                        print(f"Error translating expression: {e}")
                                        loading += "0 /* Error */"
                                else:
                                    loading += "0 /* Invalid node */"
                                
                                if data_list_element.next is not None:
                                    loading += ", "
                                    
                                byte_count += 1
                                
                                data_list_element = data_list_element.next
                            
                            if list_element.next is not None:
                                if hasattr(list_element.next, 'value') and hasattr(list_element.next.value, 'node') and list_element.next.value.node.type != AstType.AST_DATA16:
                                    loading += ","
                                else:
                                    # This only occurs at the very end of the disassembly (the interrupt vectors)
                                    # So we will ignore it
                                    break
                                    
                            # Add comments at the end of the line (if they exist)
                            if hasattr(data_item, 'line_number') and data_item.line_number != 0:
                                comment = lookup_comment(data_item.line_number)
                                if comment:
                                    # Strip the first comment character
                                    if comment.startswith(';'):
                                        cleaned_comment = comment[1:]
                                    elif comment.startswith('//'):
                                        cleaned_comment = comment[2:]
                                    else:
                                        cleaned_comment = comment
                                    loading += f" // {cleaned_comment}"
                                    
                            list_element = list_element.next
                            
                        loading += f"\n{TAB}}};\n"
                        loading += f"{TAB}writeData({label_name}, {label_name}_data, sizeof({label_name}_data));\n\n"
                        
                        # The addresses that point to the data
                        addresses += f"{TAB}uint16_t {label_name}_ptr;\n"
                        
                        address_defines += f"#define {label_name} (dataPointers.{label_name}_ptr)\n"
                        
                        address_defaults += f"{TAB}{TAB}this->{label_name}_ptr = 0x{storage_address:x};\n"
                        
                        storage_address += byte_count
                    # Alias label
                    else:
                        # For aliases, we only need to worry about referencing the aliased value
                        addresses += f"{TAB}uint16_t {label_name}_ptr; // alias\n"
                        
                        address_defines += f"#define {label_name} (dataPointers.{label_name}_ptr)\n"
                        
                        address_defaults += f"{TAB}{TAB}this->{label_name}_ptr = 0x{storage_address:x};\n"
                except Exception as e:
                    print(f"Error generating data declaration for {label_name}: {e}")
                    
        # Also store the first address of free space
        addresses += f"{TAB}uint16_t freeSpaceAddress;\n"
        address_defaults += f"{TAB}{TAB}this->freeSpaceAddress = 0x{storage_address:x};\n"
        
        # Final stuff for the end of each section...
        address_defaults += f"{TAB}}}\n"
        addresses += f"\n{address_defaults}}};\n\n"
        address_defines += "\n"
        loading += "}\n\n"
        
        # Put everything in the correct file
        self.data_header_output += "#ifndef SMBDATAPOINTERS_HPP\n#define SMBDATAPOINTERS_HPP\n\n"
        self.data_header_output += addresses
        self.data_header_output += address_defines
        self.data_header_output += "#endif // SMBDATAPOINTERS_HPP\n"
        
        self.data_output += "#include \"SMB.hpp\"\n\n"
        self.data_output += loading
        
    def index_empty_lines(self):
        """
        Find all empty lines in the file
        """
        try:
            with open(self.input_filename, "r") as f:
                for line_number, line in enumerate(f, 1):
                    if not line.strip():
                        map_newline(line_number)
        except Exception as e:
            print(f"Error reading file: {e}")
            
    def do_translation(self):
        """
        Perform the full translation process
        """
        try:
            # Find all empty lines in the file
            self.index_empty_lines()
            
            # Find all data and code labels
            self.classify_labels()
            
            # Begin generating output
            
            # Put required header
            self.source_output += "#include \"SMB.hpp\"\n\n"
            
            # Generate constant declarations first
            self.generate_constant_declarations()
            
            # Generate data declarations next
            self.generate_data_declarations()
            
            # Finally, generate code
            self.generate_code()
        except Exception as e:
            print(f"Error during translation: {e}")
        
    def translate_branch(self, condition, destination):
        """
        Translate a branch instruction to C++
        """
        # Handle both label names and expressions
        if isinstance(destination, str):
            # It's a label name
            return f"if ({condition})\n{TAB}{TAB}goto {destination};"
        else:
            # It's an expression - evaluate it and generate a goto
            dest_expr = self.translate_expression(destination)
            return f"if ({condition})\n{TAB}{TAB}goto {dest_expr};"
        
    def translate_expression(self, expr):
        """
        Translate an expression to C++ code
        """
        result = ""
        
        if expr is not None:
            if expr.type == AstType.AST_NAME:
                result = expr.value.s
            elif expr.type == AstType.AST_LOCAL_LABEL:
                # Local labels in asm6 have a dot prefix
                result = expr.value.s
            elif expr.type == AstType.AST_CURRENT_ADDR:
                # Current address symbol (*) - use PC register
                result = "PC"
            elif expr.type == AstType.AST_CONST:
                if expr.value.s[0] == ':
                    result = "0x" + expr.value.s[1:]
                elif expr.value.s[0] == '%':
                    result = "BOOST_BINARY(" + expr.value.s[1:] + ")"
                else:
                    result = expr.value.s
            elif expr.type == AstType.AST_IMMEDIATE:
                # Take the internal value literally
                result = self.translate_expression(expr.child)
            elif expr.type == AstType.AST_ADD:
                result = "(" + self.translate_expression(expr.lhs) + " + " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_SUBTRACT:
                result = "(" + self.translate_expression(expr.lhs) + " - " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_MULTIPLY:
                result = "(" + self.translate_expression(expr.lhs) + " * " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_DIVIDE:
                result = "(" + self.translate_expression(expr.lhs) + " / " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_BITWISE_AND:
                result = "(" + self.translate_expression(expr.lhs) + " & " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_BITWISE_OR:
                result = "(" + self.translate_expression(expr.lhs) + " | " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_BITWISE_XOR:
                result = "(" + self.translate_expression(expr.lhs) + " ^ " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_MODULO:
                result = "(" + self.translate_expression(expr.lhs) + " % " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_BITSHIFT_LEFT:
                result = "(" + self.translate_expression(expr.lhs) + " << " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_BITSHIFT_RIGHT:
                result = "(" + self.translate_expression(expr.lhs) + " >> " + self.translate_expression(expr.rhs) + ")"
            elif expr.type == AstType.AST_NEGATE:
                result = "(!" + self.translate_expression(expr.child) + ")"
            elif expr.type == AstType.AST_HIBYTE:
                result = "HIBYTE(" + self.translate_expression(expr.child) + ")"
            elif expr.type == AstType.AST_LOBYTE:
                result = "LOBYTE(" + self.translate_expression(expr.child) + ")"
            elif expr.type == AstType.AST_INDIRECT:
                # Check if the child is an indexed-x node inside indirect
                if hasattr(expr, 'child') and expr.child.type == AstType.AST_INDEXED_X:
                    # This is (expr,X) in asm6 syntax - indexed indirect
                    result = "M(W(M(" + self.translate_expression(expr.child.child) + " + x)))"
                else:
                    # Regular indirect
                    result = "M(" + self.translate_expression(expr.child) + ")"
            elif expr.type == AstType.AST_INDEXED_X:
                result = self.translate_expression(expr.child) + " + x"
            elif expr.type == AstType.AST_INDEXED_Y:
                # Check for the special case of indirect indexed
                if hasattr(expr, 'child') and expr.child.type == AstType.AST_INDIRECT:
                    # This is (expr),Y in asm6 syntax - indirect indexed
                    result = "W(" + self.translate_expression(expr.child.child) + ") + y"
                else:
                    # Regular indexed-y
                    result = self.translate_expression(expr.child) + " + y"
            else:
                print(f"Warning: Unexpected expression type: {expr.type}")
                result = "0 /* Unknown expression type */"
                
        return result
        
    def translate_instruction(self, inst):
        """
        Translate an instruction to C++ code
        """
        result = ""
        
        try:
            if inst.code == LDA:
                result += "a = " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == LDX:
                result += "x = " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == LDY:
                result += "y = " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == STA:
                result += "writeData(" + self.translate_expression(inst.value.node) + ", a);"
            elif inst.code == STX:
                result += "writeData(" + self.translate_expression(inst.value.node) + ", x);"
            elif inst.code == STY:
                result += "writeData(" + self.translate_expression(inst.value.node) + ", y);"
            elif inst.code == TAX:
                result = "x = a;"
            elif inst.code == TAY:
                result = "y = a;"
            elif inst.code == TXA:
                result = "a = x;"
            elif inst.code == TYA:
                result = "a = y;"
            elif inst.code == TSX:
                result = "x = s;"
            elif inst.code == TXS:
                result = "s = x;"
            elif inst.code == PHA:
                result = "pha();"
            elif inst.code == PHP:
                result = "php();"
            elif inst.code == PLA:
                result = "pla();"
            elif inst.code == PLP:
                result = "plp();"
            elif inst.code == AND:
                result += "a &= " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == EOR:
                result += "a ^= " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == ORA:
                result += "a |= " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == BIT:
                result += "bit(" + self.translate_operand(inst.value.node) + ");"
            elif inst.code == ADC:
                result += "a += " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == SBC:
                result += "a -= " + self.translate_operand(inst.value.node) + ";"
            elif inst.code == CMP:
                result += "compare(a, " + self.translate_operand(inst.value.node) + ");"
            elif inst.code == CPX:
                result += "compare(x, " + self.translate_operand(inst.value.node) + ");"
            elif inst.code == CPY:
                result += "compare(y, " + self.translate_operand(inst.value.node) + ");"
            elif inst.code == INC:
                result += "writeData(" + self.translate_expression(inst.value.node) + ", M(" + self.translate_expression(inst.value.node) + ") + 1);"
            elif inst.code == INX:
                result += "++x;"
            elif inst.code == INY:
                result += "++y;"
            elif inst.code == DEC:
                result += "writeData(" + self.translate_expression(inst.value.node) + ", M(" + self.translate_expression(inst.value.node) + ") - 1);"
            elif inst.code == DEX:
                result += "--x;"
            elif inst.code == DEY:
                result += "--y;"
            elif inst.code == ASL:
                if hasattr(inst, 'value') and inst.value.node:
                    address_expr = self.translate_expression(inst.value.node)
                    result += f"{{ uint8_t val = M({address_expr}); val <<= 1; writeData({address_expr}, val); }}"
                else:
                    result += "a <<= 1;"
            elif inst.code == LSR:
                if hasattr(inst, 'value') and inst.value.node:
                    address_expr = self.translate_expression(inst.value.node)
                    result += f"{{ uint8_t val = M({address_expr}); val >>= 1; writeData({address_expr}, val); }}"
                else:
                    result += "a >>= 1;"
            elif inst.code == ROL:
                if hasattr(inst, 'value') and inst.value.node:
                    address_expr = self.translate_expression(inst.value.node)
                    result += f"{{ uint8_t val = M({address_expr}); uint8_t carry = c; c = (val & 0x80) != 0; val = (val << 1) | carry; writeData({address_expr}, val); }}"
                else:
                    result += "{ uint8_t carry = c; c = (a & 0x80) != 0; a = (a << 1) | carry; }"
            elif inst.code == ROR:
                if hasattr(inst, 'value') and inst.value.node:
                    address_expr = self.translate_expression(inst.value.node)
                    result += f"{{ uint8_t val = M({address_expr}); uint8_t carry = c; c = (val & 0x01) != 0; val = (val >> 1) | (carry << 7); writeData({address_expr}, val); }}"
                else:
                    result += "{ uint8_t carry = c; c = (a & 0x01) != 0; a = (a >> 1) | (carry << 7); }"
            elif inst.code == JMP:
                # We need to handle both labels and expressions
                if hasattr(inst.value.node, 'type') and inst.value.node.type == AstType.AST_NAME:
                    # Check for special case (jmp EndlessLoop)
                    if inst.value.node.value.s == "EndlessLoop":
                        result += "return;"
                    else:
                        result += "goto " + self.translate_expression(inst.value.node) + ";"
                else:
                    # Handle expression jump targets
                    dest_expr = self.translate_expression(inst.value.node)
                    result += f"goto {dest_expr};"
            elif inst.code == JSR:
                # Check for special case (jsr JumpEngine)
                if isinstance(inst.value.s, str) and inst.value.s == "JumpEngine":
                    # Create a switch-case jump table
                    # using the labels that follow as data
                    result += "switch (a)\n"
                    result += TAB
                    result += "{\n"
                    
                    # Skip our element
                    list_element = inst.parent
                    if list_element is None:
                        result += TAB + "/* Invalid parent for JumpEngine */\n" + TAB + "}"
                        return result
                    
                    list_element = list_element.next
                    index = 0
                    
                    while list_element is not None:
                        result += TAB
                        result += "case "
                        result += str(index)
                        result += ":\n"
                        
                        # A little funky...
                        # We have an outer list element,
                        # which contains a 16-bit data list element (.dw),
                        # which contains another list element,
                        # which contains the name that we want to add to our jump table
                        try:
                            result += TAB
                            result += TAB
                            result += "goto "
                            result += self.translate_expression(list_element.value.node.value.node.value.node)
                            result += ";"
                        except Exception as e:
                            result += TAB
                            result += TAB
                            result += f"/* Error processing jump table entry {index}: {e} */;"
                        
                        # Add comments at the end of the line (if they exist)
                        if hasattr(list_element.value.node, 'line_number') and list_element.value.node.line_number != 0:
                            comment = lookup_comment(list_element.value.node.line_number)
                            if comment:
                                # Strip the first comment character
                                if comment.startswith(';'):
                                    cleaned_comment = comment[1:]
                                elif comment.startswith('//'):
                                    cleaned_comment = comment[2:]
                                else:
                                    cleaned_comment = comment
                                result += " // "
                                result += cleaned_comment
                                
                        result += "\n"
                        
                        list_element = list_element.next
                        index += 1
                    
                    result += TAB
                    result += "}"
                else:
                    # If the operand is a string, it's a label name
                    if isinstance(inst.value.s, str):
                        # Regular JSR
                        return_label_index_str = str(self.return_label_index)
                        result += f"JSR({inst.value.s}, {return_label_index_str});"
                        self.return_label_index += 1
                    else:
                        # JSR with an expression as target
                        return_label_index_str = str(self.return_label_index)
                        target_expr = self.translate_expression(inst.value.node)
                        result += f"JSR({target_expr}, {return_label_index_str});"
                        self.return_label_index += 1
            elif inst.code == RTS:
                result += "goto Return;"
            elif inst.code == BCC:
                result = self.translate_branch("!c", inst.value.s if isinstance(inst.value.s, str) else inst.value.node)
            elif inst.code == BCS:
                result = self.translate_branch("c", inst.value.s if isinstance(inst.value.s, str) else inst.value.node)
            elif inst.code == BEQ:
                result = self.translate_branch("z", inst.value.s if isinstance(inst.value.s, str) else inst.value.node)
            elif inst.code == BMI:
                result = self.translate_branch("n", inst.value.s if isinstance(inst.value.s, str) else inst.value.node)
            elif inst.code == BNE:
                result = self.translate_branch("!z", inst.value.s if isinstance(inst.value.s, str) else inst.value.node)
            elif inst.code == BPL:
                result = self.translate_branch("!n", inst.value.s if isinstance(inst.value.s, str) else inst.value.node)
            elif inst.code == BVC:
                result = self.translate_branch("!v", inst.value.s if isinstance(inst.value.s, str) else inst.value.node)
            elif inst.code == BVS:
                result = self.translate_branch("v", inst.value.s if isinstance(inst.value.s, str) else inst.value.node)
            elif inst.code == CLC:
                result = "c = 0;"
            elif inst.code == CLD:
                result = "d = 0;"
            elif inst.code == CLI:
                result = "i = 0;"
            elif inst.code == CLV:
                result = "v = 0;"
            elif inst.code == SEC:
                result = "c = 1;"
            elif inst.code == SED:
                result = "d = 1;"
            elif inst.code == SEI:
                result = "i = 1;"
            elif inst.code == BRK:
                result = "/* BRK instruction - software interrupt */"
            elif inst.code == NOP:
                result += "; // nop"
            elif inst.code == RTI:
                result += "return;"
            else:
                result = f"/* Unknown instruction code: {inst.code} */;"
        except Exception as e:
            result = f"/* Error translating instruction: {e} */;"
            
        return result
        
    def translate_operand(self, operand):
        """
        Translate an operand to C++ code
        """
        result = ""
        
        try:
            if operand is not None:
                # If immediate addressing is not the underlying node, it means read from memory
                if operand.type != AstType.AST_IMMEDIATE:
                    result = "M(" + self.translate_expression(operand) + ")"
                else:
                    result = self.translate_expression(operand)
        except Exception as e:
            result = f"/* Error translating operand: {e} */"
                
        return result
